<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dice Potions Prototype</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Manrope:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: radial-gradient(circle at 20% 20%, rgba(108, 240, 194, 0.08), transparent 28%),
        radial-gradient(circle at 80% 10%, rgba(255, 176, 84, 0.08), transparent 26%),
        linear-gradient(135deg, #0c1523 0%, #0f1f31 45%, #142d2f 100%);
      --card: rgba(255, 255, 255, 0.06);
      --card-strong: rgba(255, 255, 255, 0.12);
      --text: #e9f5ff;
      --muted: #9fbad2;
      --accent: #ffb054;
      --accent-2: #6cf0c2;
      --rarity-common: rgba(255, 255, 255, 0.06);
      --rarity-uncommon: rgba(110, 225, 255, 0.12);
      --rarity-rare: rgba(170, 140, 255, 0.14);
      --rarity-legendary: rgba(255, 200, 120, 0.18);
      --rarity-mythic: rgba(255, 110, 110, 0.2);
      --danger: #f16f6f;
      --ok: #7ee0ff;
      --border: rgba(255, 255, 255, 0.16);
      --shadow: 0 10px 32px rgba(0, 0, 0, 0.32);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: 'Manrope', system-ui, -apple-system, sans-serif;
      display: flex;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: min(1200px, 100%);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px 20px;
      box-shadow: var(--shadow);
    }

    h1 {
      margin: 0;
      font-family: 'Chakra Petch', 'Manrope', sans-serif;
      letter-spacing: 1px;
      font-size: 24px;
      text-transform: uppercase;
    }

    .cta-row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .cta-row.nowrap { flex-wrap: wrap; }
    .cta-row.nowrap button { flex: 1 1 140px; min-width: 120px; max-width: 100%; }

    button {
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
      color: var(--text);
      padding: 9px 14px;
      min-height: 42px;
      min-width: 100px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      font-family: 'Chakra Petch', 'Manrope', sans-serif;
      letter-spacing: 0.2px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
      transition: transform 0.12s ease, background 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
      white-space: nowrap;
    }

    button:hover { transform: translateY(-1px); background: rgba(255, 255, 255, 0.12); box-shadow: 0 8px 20px rgba(0, 0, 0, 0.24); }
    button:active { transform: translateY(0); }
    button:disabled { opacity: 0.45; cursor: not-allowed; transform: none; box-shadow: none; }

    .grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      align-items: stretch;
    }

    #rollStage {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    @media (max-width: 920px) {
      #rollStage { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 150px;
    }

    .panel h2 {
      margin: 0;
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--muted);
    }

    .stats {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 13px;
    }

    .stats.nowrap { flex-wrap: nowrap; }
    .stats.nowrap .stat-pill { flex: 1; text-align: center; }

    .stat-pill {
      background: rgba(255, 255, 255, 0.07);
      border: 1px solid var(--border);
      padding: 6px 9px;
      border-radius: 10px;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .dice-row { display: flex; gap: 10px; flex-wrap: wrap; }

    .die-card {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      min-width: 120px;
      flex: 1 1 140px;
      position: relative;
      overflow: hidden;
    }

    .die-card.reroll-ready {
      box-shadow: 0 0 0 2px rgba(255, 176, 84, 0.45), 0 8px 24px rgba(255, 176, 84, 0.25);
      border-color: var(--accent);
      animation: rerollPulse 1.2s ease-in-out infinite;
    }

    .select-glow {
      box-shadow: 0 0 0 2px rgba(108, 240, 194, 0.5), 0 10px 26px rgba(108, 240, 194, 0.25);
      border-color: rgba(108, 240, 194, 0.6) !important;
    }

    .select-glow-danger {
      box-shadow: 0 0 0 2px rgba(241, 111, 111, 0.45), 0 10px 26px rgba(241, 111, 111, 0.25);
      border-color: rgba(241, 111, 111, 0.7) !important;
    }

    @keyframes rerollPulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 176, 84, 0.4); }
      50% { box-shadow: 0 0 0 6px rgba(255, 176, 84, 0.18); }
      100% { box-shadow: 0 0 0 0 rgba(255, 176, 84, 0.0); }
    }

    .die-card strong { display: block; font-size: 15px; margin-bottom: 6px; }
    .tag { display: inline-block; padding: 4px 8px; border-radius: 999px; font-size: 12px; }

    .tag.gold { background: rgba(255, 176, 84, 0.2); color: #ffd39a; }
    .tag.health { background: rgba(110, 215, 150, 0.18); color: #b8ffd5; }
    .tag.mana { background: rgba(110, 185, 255, 0.18); color: #cbe4ff; }
    .tag.flame { background: rgba(255, 120, 120, 0.2); color: #ffc8c8; }
    .tag.essence { background: rgba(255, 245, 161, 0.18); color: #fff7c2; }
    .tag.toxin { background: rgba(180, 120, 255, 0.18); color: #f1ddff; }
    .tag.effect { background: rgba(145, 255, 228, 0.18); color: #d9fff2; }
    .tag.blank { background: rgba(255, 255, 255, 0.12); color: #d6d6d6; }

    .pill-row { display: flex; gap: 6px; flex-wrap: wrap; }

    .face-chip {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid var(--border);
      padding: 6px 8px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }

    .face-chip.rarity-common { background: var(--rarity-common); }
    .face-chip.rarity-uncommon { background: var(--rarity-uncommon); }
    .face-chip.rarity-rare { background: var(--rarity-rare); }
    .face-chip.rarity-legendary { background: var(--rarity-legendary); }
    .face-chip.rarity-mythic { background: var(--rarity-mythic); }

    .die-card.rarity-common { background: var(--rarity-common); }
    .die-card.rarity-uncommon { background: var(--rarity-uncommon); }
    .die-card.rarity-rare { background: var(--rarity-rare); }
    .die-card.rarity-legendary { background: var(--rarity-legendary); }
    .die-card.rarity-mythic { background: var(--rarity-mythic); }

    .face-chip .mini-tag { padding: 2px 6px; border-radius: 999px; background: rgba(255,255,255,0.1); font-size: 11px; }

    .inventory-row { display: flex; flex-direction: column; gap: 10px; }

    .list { display: flex; flex-direction: column; gap: 8px; }
    .list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      gap: 10px;
    }

    .list-item .meta { color: var(--muted); font-size: 13px; }

    .log {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px 14px;
      box-shadow: var(--shadow);
      max-height: 200px;
      overflow-y: auto;
      backdrop-filter: blur(6px);
    }

    .log-entry { color: var(--muted); font-size: 13px; margin: 4px 0; }

    .badge { padding: 4px 8px; background: rgba(255,255,255,0.08); border-radius: 999px; font-size: 12px; }

    .rarity-tag { display: inline-block; width: 14px; height: 14px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.35); }
    .rarity-common { background: var(--rarity-common); border-color: rgba(255,255,255,0.12); }
    .rarity-uncommon { background: var(--rarity-uncommon); border-color: rgba(110, 225, 255, 0.35); }
    .rarity-rare { background: var(--rarity-rare); border-color: rgba(170, 140, 255, 0.5); }
    .rarity-legendary { background: var(--rarity-legendary); border-color: rgba(255, 200, 120, 0.7); }
    .rarity-mythic { background: var(--rarity-mythic); border-color: rgba(255, 110, 110, 0.85); }

    .list-item.rarity-common { background: var(--rarity-common); }
    .list-item.rarity-uncommon { background: var(--rarity-uncommon); }
    .list-item.rarity-rare { background: var(--rarity-rare); }
    .list-item.rarity-legendary { background: var(--rarity-legendary); }
    .list-item.rarity-mythic { background: var(--rarity-mythic); }

    .empty { color: var(--muted); font-size: 14px; }

    .flex { display: flex; gap: 8px; align-items: center; }
    .space-between { justify-content: space-between; }

    .hint { color: var(--muted); font-size: 12px; line-height: 1.4; }

    input, select {
      width: 100%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-family: 'Manrope', system-ui, sans-serif;
    }

    input:focus, select:focus {
      outline: 2px solid rgba(108, 240, 194, 0.5);
      border-color: rgba(108, 240, 194, 0.5);
    }

    .progress {
      height: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    /* Ensure hidden elements do not render */
    .hidden { display: none !important; }

    .progress div { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 20;
    }

    .modal-backdrop.hidden {
      display: none !important;
      opacity: 0 !important;
      visibility: hidden !important;
      pointer-events: none !important;
    }

    .modal {
      max-height: 90vh;
      overflow-y: auto;
    }

    .stats-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .stats-list .list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stats-list .list .list-item { width: 100%; }

    .gameover-modal {
      width: min(640px, 90vw);
      gap: 10px;
    }

    .stats-modal {
      width: min(640px, 90vw);
      gap: 10px;
    }

    button {
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
      color: var(--text);
      padding: 8px 12px;
      min-height: 40px;
      min-width: 96px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      font-family: 'Chakra Petch', 'Manrope', sans-serif;
      letter-spacing: 0.2px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
      transition: transform 0.12s ease, background 0.2s ease, border 0.2s ease, box-shadow 0.2s ease;
      white-space: nowrap;
    }

    .start-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 14px;
      padding: 24px;
    }

    .character-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin: 12px auto;
      max-width: 820px;
      width: 100%;
    }

    .character-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.04);
      cursor: pointer;
      text-align: left;
      transition: border 0.15s ease, box-shadow 0.15s ease, transform 0.12s ease;
    }

    .character-card:hover { transform: translateY(-2px); border-color: var(--accent); }
    .character-card.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(255,255,255,0.08); }
    .character-card h3 { margin: 0 0 6px; font-size: 16px; }
    .character-card .meta { color: var(--muted); font-size: 13px; }

    .hero-title { font-size: 32px; margin: 0; letter-spacing: 2px; text-transform: uppercase; }
    .hero-sub { color: var(--muted); margin: 4px 0 16px; }

    @media (max-width: 720px) {
      body { padding: 10px; }
      header { flex-direction: column; align-items: flex-start; gap: 10px; }
      .cta-row { width: 100%; }
      button { width: auto; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="progress hidden" aria-label="round progress">
      <div id="progressBar" style="width: 0%"></div>
    </div>

    <div id="recipeModalWrapper" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-label="Recipe Book">
      <div class="modal">
        <div class="flex space-between" style="margin-bottom: 10px;">
          <h2>Recipe Book</h2>
          <div class="cta-row">
            <button id="closeRecipeBook">Close</button>
          </div>
        </div>
        <div class="hint" style="margin-bottom: 8px;">Plan ahead: ingredients, effects, and sell values.</div>
        <div id="recipeBook" class="list"></div>
      </div>
    </div>

    <div id="invalidBrewModal" class="modal-backdrop hidden" role="alertdialog" aria-modal="true" aria-label="Invalid Brew">
      <div class="modal">
        <div class="flex space-between" style="margin-bottom: 10px; align-items:center;">
          <h2>Invalid Brew</h2>
          <button id="closeInvalidBrew">Close</button>
        </div>
        <div class="hint">That combination is not in your recipe book. Try a different mix.</div>
      </div>
    </div>

    <div id="statsModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-label="Game Stats">
      <div class="modal stats-modal">
        <div class="flex space-between" style="margin-bottom: 10px; align-items:center;">
          <h2>Stats</h2>
          <div class="cta-row">
            <button id="closeStats">Close</button>
          </div>
        </div>
        <div id="lifetimeBlock" class="stats-list">
          <div id="lifetimeStats" class="list"></div>
        </div>
      </div>
    </div>

    <div id="gameOverModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-label="Run Complete">
      <div class="modal gameover-modal">
        <div class="flex space-between" style="margin-bottom: 10px; align-items:center;">
          <h2>Run Complete</h2>
          <div class="cta-row">
            <button id="closeGameOver">Back to Start</button>
          </div>
        </div>
        <div id="gameOverStats" class="stats-list"></div>
      </div>
    </div>

    <div id="settingsModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-label="Settings">
      <div class="modal">
        <div class="flex space-between" style="margin-bottom: 10px; align-items:center;">
          <h2>Settings</h2>
          <div class="cta-row">
            <button id="closeSettings">Close</button>
          </div>
        </div>
        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap:12px;">
          <label class="list-item" style="display:block;">
              <div><strong>Starting dice</strong><div class="meta">Number of apprentice dice at game start (1-9)</div></div>
            <input id="settingStartingDice" type="number" min="1" max="9" value="3" style="width:100%; margin-top:6px;">
          </label>
          <label class="list-item" style="display:block;">
            <div><strong>Starting gold</strong><div class="meta">Initial coins at game start (0+)</div></div>
            <input id="settingStartingGold" type="number" min="0" value="0" style="width:100%; margin-top:6px;">
          </label>
          <label class="list-item" style="display:block;">
            <div><strong>Rounds</strong><div class="meta">How many rounds per game (1-99)</div></div>
            <input id="settingMaxRounds" type="number" min="1" max="99" value="12" style="width:100%; margin-top:6px;">
          </label>
          <label class="list-item" style="display:block;">
            <div><strong>Shop item slots</strong><div class="meta">How many item offers appear per shop reroll (1-6)</div></div>
            <input id="settingShopSlots" type="number" min="1" max="6" value="3" style="width:100%; margin-top:6px;">
          </label>
        </div>
        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:12px; margin-top:10px;">
          <div class="list-item" style="display:block;">
            <div><strong>Toggle shop items</strong><div class="meta">Enable/disable individual shop items.</div></div>
            <div id="settingItemToggles" class="inventory-row" style="max-height:160px; overflow:auto; margin-top:8px;"></div>
          </div>
          <div class="list-item" style="display:block;">
            <div><strong>Toggle dice types</strong><div class="meta">Enable/disable which dice appear for sale.</div></div>
            <div id="settingDieToggles" class="inventory-row" style="max-height:160px; overflow:auto; margin-top:8px;"></div>
          </div>
          <div class="list-item" style="display:block;">
            <div><strong>Toggle face offers</strong><div class="meta">Enable/disable which faces can appear in the face shop.</div></div>
            <div id="settingFaceToggles" class="inventory-row" style="max-height:160px; overflow:auto; margin-top:8px;"></div>
          </div>
        </div>
        <div class="cta-row" style="margin-top:12px; justify-content:flex-end;">
          <button id="resetSettings">Reset Defaults</button>
          <button id="saveSettings">Save Settings</button>
        </div>
      </div>
    </div>

    <section id="startScreen" class="panel start-panel">
      <div id="startIntro">
        <h2 class="hero-title">Dice Potions</h2>
        <div class="hero-sub">Roll, brew, trade. Choose your path.</div>
        <div class="cta-row" style="justify-content:center; margin-bottom:8px;">
          <button id="startHowToBtn">How to Play</button>
        </div>
        <div id="howToPlay" class="list hidden" style="text-align:left; max-width:680px; margin:0 auto; gap:6px; color: var(--muted);">
          <div class="list-item" style="background: rgba(255,255,255,0.04);">
            <div><strong>1) Roll</strong><div class="meta">Roll your dice for gold and ingredients. Face effects (boosts, copies, doubles, shields) apply automatically. Reroll tokens (or items) let you reroll a single die before moving on.</div></div>
          </div>
          <div class="list-item" style="background: rgba(255,255,255,0.04);">
            <div><strong>2) Brew</strong><div class="meta">Drop rolled ingredients into the cauldron to match a recipe, then Brew. Potions can be consumed for immediate effects or sold for gold. Clearing the cauldron removes ingredients, so brew before you leave the roll stage.</div></div>
          </div>
          <div class="list-item" style="background: rgba(255,255,255,0.04);">
            <div><strong>3) Shop</strong><div class="meta">Between rounds, buy items (consumable or permanent), new dice, or faces. Face buys ask you to click a die face to swap it in; removal tokens let you delete a face. Extra die slots get pricier (25/50/75). Use reroll tokens or gold to refresh offers.</div></div>
          </div>
          <div class="list-item" style="background: rgba(255,255,255,0.04);">
            <div><strong>4) Rounds & ending</strong><div class="meta">Runs are capped (default 10 rounds). The shop button shows End Game on the final round. Status effects often expire at round end; some give passive gold at round start. Push for score before the cap hits.</div></div>
          </div>
        </div>
        <div class="cta-row" style="justify-content:center;">
          <button id="startGameBtn">Start Game</button>
          <button id="startRecipeBtn">Recipe Book</button>
        </div>
        <div class="cta-row" style="justify-content:center;">
          <button id="startStatsBtn">Player Stats</button>
          <button id="startSettingsBtn">Settings</button>
        </div>
      </div>

      <div id="characterSelectView" class="hidden">
        <h2 class="hero-title">Choose Your Brewer</h2>
        <div class="hero-sub">Each brewer starts with a unique perk.</div>
        <div id="characterGrid" class="character-grid hidden"></div>
        <div class="cta-row" style="justify-content:center; margin-top:8px;">
          <button id="chooseCharacterBtn">Choose Character</button>
        </div>
      </div>
    </section>

    <div id="playView" class="hidden">
      <div class="grid" id="rollStage">
        <section class="panel" id="dicePanel">
          <div class="flex space-between" style="align-items:center; gap:12px; flex-wrap:wrap;">
            <div class="flex" style="align-items:center; gap:8px; flex-wrap:nowrap;">
              <h2 style="margin:0; white-space:nowrap;">Roll</h2>
              <div class="stats nowrap" style="gap:6px; font-size:12px;">
                <span class="stat-pill" style="padding:6px 10px;">Round <span id="roundLabel"></span></span>
                <span class="stat-pill" style="padding:6px 10px;">Gold: <span id="goldLabel"></span></span>
                <span class="stat-pill" style="padding:6px 10px;">Score: <span id="scoreLabel"></span></span>
              </div>
            </div>
            <div class="cta-row nowrap" style="justify-content:flex-end; flex-wrap:nowrap; gap:8px;">
              <button id="rollBtn">Roll Dice</button>
              <button id="toShopBtn" disabled>Go To Store</button>
              <button id="nextBtn" class="hidden" disabled>Next Round</button>
            </div>
          </div>
          <div id="diceRow" class="dice-row"></div>
        </section>

        <section class="panel">
          <div class="flex space-between" style="align-items:flex-start;">
            <h2>Cauldron & Potions</h2>
            <button id="openRecipeBook">Recipe Book</button>
          </div>
          <div id="ingredientsRow" class="inventory-row"></div>
          <div class="hint"></div>
          <div class="flex space-between" style="align-items:flex-start; gap:10px;">
            <div style="flex:1;">
              <div class="pill-row" id="cauldronRow"></div>
            </div>
            <div class="cta-row">
              <button id="brewBtn">Brew</button>
              <button id="autoBrewBtn">Auto Brew</button>
              <button id="clearCauldron">Clear</button>
            </div>
          </div>
          <div id="potionsList" class="list"></div>
        </section>

        <section class="panel" style="grid-column: 1 / -1;">
          <div class="flex space-between" style="align-items:flex-start;">
            <h2>Items</h2>
            <div class="hint"></div>
          </div>
          <div id="itemInventoryRoll" class="inventory-row"></div>
        </section>
      </div>

      <div id="shopStage" class="grid">
        <section class="panel">
          <div class="flex space-between" style="align-items:flex-start;">
            <h2>Inventory</h2>
            <div class="flex" style="gap:8px; align-items:center;">
              <span class="stat-pill">Round: <span id="invRound"></span></span>
              <span class="stat-pill">Gold: <span id="invGold"></span></span>
              <span class="stat-pill">Dice: <span id="invDice"></span></span>
              <button id="backToBrew">Start Next Round</button>
            </div>
          </div>
          <h3>Dice</h3>
          <div id="diceInventoryList" class="inventory-row"></div>
          <h3>Potions</h3>
          <div class="cta-row" style="margin-bottom:6px;">
            <button id="sellAllShop" disabled>Sell All Potions</button>
          </div>
          <div id="potionInventoryList" class="inventory-row"></div>
          <h3>Items</h3>
          <div id="itemInventoryList" class="inventory-row"></div>
        </section>

        <section class="panel">
          <div class="flex space-between" style="align-items:flex-start;">
            <div>
              <h2>Shop</h2>
              <div class="hint">Buy between rolls. Potions can also be consumed.</div>
            </div>
            <div class="cta-row">
              <button id="rerollShop">Reroll Shop (-3 Gold or 1 token)</button>
            </div>
          </div>
          <div id="shopList" class="list"></div>
          <h2>Dice For Sale</h2>
          <div class="hint">Each die shows its six faces.</div>
          <div id="extraSlotRow" class="flex space-between" style="align-items:center; gap:10px; margin:6px 0 8px 0;">
            <div class="hint" id="extraSlotLabel">Buy extra die slots to hold more dice.</div>
            <button id="buyExtraSlotBtn">Buy +1 Die Slot</button>
          </div>
          <div id="diceShopList" class="inventory-row"></div>
          <h2>Die Faces For Sale</h2>
          <div class="hint">Buy a face, then click a face on one of your dice to swap it in.</div>
          <div id="faceShopList" class="list"></div>
        </section>
      </div>

      <section class="panel">
        <h2>Round Effects</h2>
        <div id="statusRow" class="pill-row"></div>
        <div class="hint"></div>
      </section>

      <div class="log hidden" id="log"></div>
    </div>
  </div>

  <script>
    // Safety: ensure all modals start hidden even if later script errors occur
    document.addEventListener('DOMContentLoaded', () => {
      ['settingsModal', 'recipeModalWrapper', 'invalidBrewModal', 'statsModal', 'gameOverModal'].forEach((id) => {
        const el = document.getElementById(id);
        if (el && !el.classList.contains('hidden')) {
          el.classList.add('hidden');
        }
        if (el) el.style.removeProperty('display');
      });
    });

    // Game data
    const ingredients = ['health', 'mana', 'flame', 'essence', 'toxin'];
    const ingredientLabels = {
      health: 'Health Leaf',
      mana: 'Mana Bloom',
      flame: 'Flame Pepper',
      essence: 'Golden Essence',
      toxin: 'Toxic Spores'
    };

    const defaultSettings = {
      startingDice: 3,
      startingGold: 0,
      maxRounds: 10,
      shopItemSlots: 3,
      enabledItems: null,
      enabledDiceTypes: null,
      enabledFaces: null
    };


    let settings = { ...defaultSettings };

    const STORAGE_KEYS = {
      settings: 'dice_potions_settings_v1',
      lifetimeStats: 'dice_potions_lifetime_v1'
    };

    function loadSettingsFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEYS.settings);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        settings = { ...defaultSettings, ...parsed };
        ensureToggleDefaults();
      } catch (err) {
        console.warn('Failed to load saved settings', err);
        settings = { ...defaultSettings };
      }
    }

    function saveSettingsToStorage() {
      try {
        localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(settings));
      } catch (err) {
        console.warn('Failed to save settings', err);
      }
    }

    const lifetimeStats = {
      gamesPlayed: 0,
      potionsBrewed: 0,
      potionsConsumed: 0,
      potionValue: 0,
      itemsBought: 0,
      highScore: 0,
      ingredients: { health: 0, mana: 0, flame: 0, essence: 0, toxin: 0 }
    };

    function loadLifetimeStatsFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEYS.lifetimeStats);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        ['gamesPlayed', 'potionsBrewed', 'potionsConsumed', 'potionValue', 'itemsBought', 'highScore'].forEach((key) => {
          if (typeof parsed[key] === 'number' && Number.isFinite(parsed[key])) {
            lifetimeStats[key] = parsed[key];
          }
        });
        if (parsed.ingredients) {
          ingredients.forEach((ing) => {
            if (typeof parsed.ingredients[ing] === 'number' && Number.isFinite(parsed.ingredients[ing])) {
              lifetimeStats.ingredients[ing] = parsed.ingredients[ing];
            }
          });
        }
      } catch (err) {
        console.warn('Failed to load lifetime stats', err);
      }
    }

    function saveLifetimeStatsToStorage() {
      try {
        localStorage.setItem(STORAGE_KEYS.lifetimeStats, JSON.stringify(lifetimeStats));
      } catch (err) {
        console.warn('Failed to save lifetime stats', err);
      }
    }

    const diceCatalog = [
      { id: 'apprentice', name: 'Apprentice Die', price: 0, faces: [
        { kind: 'gold', gold: 1, label: 'Coins +1', tag: 'gold' },
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'health', count: 2, label: 'Health Leaf x2', tag: 'health' }
      ] },
      { id: 'goldsmith', name: 'Goldsmith Die', price: 7, faces: [
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'gold', gold: 4, label: 'Coins +4', tag: 'gold' },
        { kind: 'gold', gold: 5, label: 'Coins +5', tag: 'gold' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'ember', name: 'Volatile Ember Die', price: 6, faces: [
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' },
        { kind: 'effect', effect: 'boostGold', label: '+1 Gold per ingredient rolled', tag: 'effect' },
        { kind: 'effect', effect: 'toxin', label: 'Toxin: lose 2 Gold', tag: 'toxin' }
      ] },
      { id: 'prismatic', name: 'Prismatic Die', price: 8, faces: [
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'effect', effect: 'wildIngredient', label: 'Random ingredient', tag: 'effect' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' }
      ] },
      { id: 'herbal', name: 'Herbalist Die', price: 5, faces: [
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'spark', name: 'Spark Die', price: 5, faces: [
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'effect', effect: 'boostGold', label: '+1 Gold per ingredient rolled', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'toxin', name: 'Toxin Die', price: 4, faces: [
        { kind: 'ingredient', ingredient: 'toxin', label: 'Toxic Spores', tag: 'toxin' },
        { kind: 'ingredient', ingredient: 'toxin', label: 'Toxic Spores', tag: 'toxin' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'miner', name: 'Miner Die', price: 6, faces: [
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'gold', gold: 4, label: 'Coins +4', tag: 'gold' },
        { kind: 'gold', gold: 5, label: 'Coins +5', tag: 'gold' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'mint_aura', name: 'Mint Aura Die', price: 9, faces: [
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'gold', gold: 4, label: 'Coins +4', tag: 'gold' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'effect', effect: 'goldAura', label: 'Mint Aura: +1 to all rolled gold faces', tag: 'effect' }
      ] },
      { id: 'essence', name: 'Essence Die', price: 5, faces: [
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'effect', effect: 'wildIngredient', label: 'Random ingredient', tag: 'effect' },
        { kind: 'effect', effect: 'boostGold', label: '+1 Gold per ingredient rolled', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'balanced', name: 'Balanced Die', price: 6, faces: [
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' }
      ] },
      { id: 'wildling', name: 'Wildling Die', price: 7, faces: [
        { kind: 'effect', effect: 'wildIngredient', label: 'Random ingredient', tag: 'effect' },
        { kind: 'effect', effect: 'wildIngredient', label: 'Random ingredient', tag: 'effect' },
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' }
      ] },
      { id: 'copycat', name: 'Copycat Die', price: 7, faces: [
        { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' },
        { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'guardian', name: 'Guardian Die', price: 6, faces: [
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'effect', effect: 'boostGold', label: '+1 Gold per ingredient rolled', tag: 'effect' }
      ] },
      { id: 'emberlord', name: 'Emberlord Die', price: 8, faces: [
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'effect', effect: 'boostGold', label: '+1 Gold per ingredient rolled', tag: 'effect' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'essence_crown', name: 'Essence Crown Die', price: 8, faces: [
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'gold', gold: 4, label: 'Coins +4', tag: 'gold' },
        { kind: 'effect', effect: 'wildIngredient', label: 'Random ingredient', tag: 'effect' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' }
      ] },
      { id: 'manastorm', name: 'Manastorm Die', price: 7, faces: [
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'toxin_ward', name: 'Toxin Ward Die', price: 6, faces: [
        { kind: 'ingredient', ingredient: 'toxin', label: 'Toxic Spores', tag: 'toxin' },
        { kind: 'ingredient', ingredient: 'toxin', label: 'Toxic Spores', tag: 'toxin' },
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'jackpot', name: 'Jackpot Die', price: 9, faces: [
        { kind: 'gold', gold: 6, label: 'Coins +6', tag: 'gold' },
        { kind: 'gold', gold: 0, label: 'Bust (0)', tag: 'blank' },
        { kind: 'gold', gold: 4, label: 'Coins +4', tag: 'gold' },
        { kind: 'gold', gold: 5, label: 'Coins +5', tag: 'gold' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'hybrid', name: 'Hybrid Die', price: 7, faces: [
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' },
        { kind: 'effect', effect: 'wildIngredient', label: 'Random ingredient', tag: 'effect' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'budget', name: 'Budget Die', price: 3, faces: [
        { kind: 'gold', gold: 1, label: 'Coins +1', tag: 'gold' },
        { kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' },
        { kind: 'ingredient', ingredient: 'health', label: 'Health Leaf', tag: 'health' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'blank', label: 'Void face', tag: 'blank' }
      ] },
      { id: 'artisan', name: 'Artisan Die', price: 8, faces: [
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'ingredient', ingredient: 'essence', label: 'Golden Essence', tag: 'essence' },
        { kind: 'ingredient', ingredient: 'flame', label: 'Flame Pepper', tag: 'flame' },
        { kind: 'ingredient', ingredient: 'mana', label: 'Mana Bloom', tag: 'mana' },
        { kind: 'effect', effect: 'boostGold', label: '+1 Gold per ingredient rolled', tag: 'effect' },
        { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' }
      ] }
    ];

    const extraSlotCosts = [25, 50, 75];
    const diceRegistry = {};

    function registerDieDef(def) {
      diceRegistry[def.id] = def;
    }

    diceCatalog.forEach(registerDieDef);

    function shuffle(arr) {
      const copy = [...arr];
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function weightedPick(arr, weightFn = () => 1) {
      if (!arr.length) return null;
      const weights = arr.map(weightFn);
      const total = weights.reduce((a, b) => a + b, 0);
      if (total <= 0) return pick(arr);
      let r = Math.random() * total;
      for (let i = 0; i < arr.length; i += 1) {
        r -= weights[i];
        if (r <= 0) return arr[i];
      }
      return arr[arr.length - 1];
    }

    const dieBaseTiers = [
      { id: 'apprenticeBase', adj: 'Apprentice', price: 4, goldValues: [1, 2, 3], weight: 1.2 },
      { id: 'journeymanBase', adj: 'Journeyman', price: 6, goldValues: [2, 3, 4], weight: 1.0 },
      { id: 'masterworkBase', adj: 'Masterwork', price: 8, goldValues: [3, 4, 5], weight: 0.6 }
    ];

    const dieIngredientPacks = [
      { id: 'herbalPack', adj: 'Herbal', price: 2, faces: ['health', 'health'], weight: 1.1 },
      { id: 'manaPack', adj: 'Arcane', price: 2, faces: ['mana', 'mana'], weight: 1.0 },
      { id: 'flamePack', adj: 'Blazing', price: 2, faces: ['flame', 'flame'], weight: 1.0 },
      { id: 'essencePack', adj: 'Gilded', price: 3, faces: ['essence', 'essence'], weight: 0.6 },
      { id: 'toxinPack', adj: 'Venom', price: 2, faces: ['toxin', 'toxin'], weight: 1.0 },
      { id: 'richManaPack', adj: 'Saturated', price: 3, faces: [{ ingredient: 'mana', count: 2 }], weight: 0.5 },
      { id: 'richFlamePack', adj: 'Blazing Rich', price: 3, faces: [{ ingredient: 'flame', count: 2 }], weight: 0.5 },
      { id: 'wildPack', adj: 'Prismatic', price: 4, faces: ['health', 'mana', 'flame'], weight: 0.5 },
      { id: 'mixedPack', adj: 'Forager', price: 2, faces: ['health', 'mana', 'essence'], weight: 0.9 }
    ];

    const dieEffectPacks = [
      { id: 'fortune', adj: 'Fortune', price: 2, face: { kind: 'effect', effect: 'doubleHighestGold', label: 'Double your best gold die', tag: 'effect' }, weight: 0.25 },
      { id: 'copycat', adj: 'Copycat', price: 2, face: { kind: 'effect', effect: 'copyIngredient', label: 'Copy a rolled ingredient', tag: 'effect' }, weight: 0.7 },
      { id: 'wild', adj: 'Wild', price: 2, face: { kind: 'effect', effect: 'wildIngredient', label: 'Random ingredient', tag: 'effect' }, weight: 0.7 },
      { id: 'greedy', adj: 'Greedy', price: 2, face: { kind: 'effect', effect: 'boostGold', label: '+1 Gold per ingredient rolled', tag: 'effect' }, weight: 1.0 },
      { id: 'minted', adj: 'Minted', price: 3, face: { kind: 'effect', effect: 'goldAura', label: 'Mint Aura: +1 to all rolled gold faces', tag: 'effect' }, weight: 0.35 },
      { id: 'jackpot', adj: 'Jackpot', price: 3, face: { kind: 'effect', effect: 'doubleGoldAll', label: 'Double all Gold this roll', tag: 'effect' }, weight: 0.15 },
      { id: 'attuned', adj: 'Attuned', price: 3, face: { kind: 'effect', effect: 'doubleIngredient', ing: 'essence', label: 'Double essence this roll', tag: 'effect' }, weight: 0.2 }
    ];

    function faceForIngredient(ing) {
      if (typeof ing === 'object' && ing !== null) {
        const base = ing.ingredient || 'mana';
        const count = Math.max(1, ing.count || 1);
        return { kind: 'ingredient', ingredient: base, count, label: `${ingredientLabels[base] || base}${count > 1 ? ` x${count}` : ''}`, tag: base };
      }
      return { kind: 'ingredient', ingredient: ing, label: ingredientLabels[ing] || ing, tag: ing };
    }

    function makeGeneratedDie() {
      const base = weightedPick(dieBaseTiers, (t) => t.weight || 1) || dieBaseTiers[0];
      const ingPack = weightedPick(dieIngredientPacks, (p) => p.weight || 1) || dieIngredientPacks[0];
      const effPack = weightedPick(dieEffectPacks, (p) => p.weight || 1) || dieEffectPacks[0];

      const faces = [];
      base.goldValues.forEach((g) => faces.push({ kind: 'gold', gold: g, label: `Coins +${g}` }));
      ingPack.faces.forEach((f) => { faces.push(typeof f === 'string' ? faceForIngredient(f) : faceForIngredient(f)); });
      faces.push(cloneFace(effPack.face));

      // Ensure every generated die ends with exactly six faces
      while (faces.length > 6) {
        faces.splice(Math.floor(Math.random() * faces.length), 1);
      }
      while (faces.length < 6) {
        faces.push({ kind: 'blank', label: 'Void face', tag: 'blank' });
      }

      const genId = `gen-${Math.random().toString(36).slice(2)}`;
      const die = {
        id: genId,
        typeId: genId,
        name: `${base.adj} ${ingPack.adj}`,
        price: Math.max(4, Math.round(base.price + ingPack.price + effPack.price)),
        faces
      };

      registerDieDef(die);
      return die;
    }

    const ingredientValues = { mana: 2, health: 3, flame: 5, essence: 7, toxin: 4 };
    function recipeSell(ings, bonus = 0) {
      const base = ings.reduce((sum, ing) => sum + (ingredientValues[ing] || 2), 0);
      const sizeBonus = Math.max(0, ings.length - 1) * 2;
      const rarityBonus = ings.filter((i) => i === 'flame' || i === 'essence' || i === 'toxin').length;
      return base + sizeBonus + rarityBonus + bonus;
    }

    const recipes = [
      // Single-ingredient brews (common basics)
      { id: 'mana_single', name: 'Focus Draught', ingredients: ['mana'], sell: recipeSell(['mana']), consume: { type: 'reroll', text: 'Gain 1 shop reroll token (refresh shop)', rerolls: 1 } },
      { id: 'health_single', name: 'Minor Remedy', ingredients: ['health'], sell: recipeSell(['health']), consume: { type: 'dieReroll', text: 'Gain 1 die reroll (click a die after rolling)' } },

      // Common multi-ingredient brews
      { id: 'health_health_reroll', name: 'Greater Remedy', ingredients: ['health', 'health'], sell: 8, rarity: 'common', consume: { type: 'dieReroll', text: 'Gain 3 die rerolls (use after rolling)', amount: 3 } },
      { id: 'mana_mana_reroll', name: 'Twin Focus Draught', ingredients: ['mana', 'mana'], sell: 6, rarity: 'common', consume: { type: 'reroll', text: 'Gain 3 shop reroll tokens (refresh shop)', rerolls: 3 } },
      { id: 'health_mana', name: 'Rejuvenation Draught', ingredients: ['health', 'mana'], sell: recipeSell(['health', 'mana']), consume: { type: 'cloneDie', text: 'Next roll gains a bonus copy of a random die' } },

      // Uncommon single-ingredient brews (one-cost)
      { id: 'essence_income', name: 'Essence Dividend', ingredients: ['essence'], sell: 8, rarity: 'uncommon', consume: { type: 'passiveGoldPerRound', text: 'Gain +2 Gold each round for the rest of the game', amount: 2 } },
      { id: 'flame_single_score', name: 'Ember Laurels', ingredients: ['flame'], sell: 7, rarity: 'uncommon', consume: { type: 'score', text: 'Gain 15 points immediately', amount: 15 } },
      { id: 'toxin_banked_gold', name: 'Vile Investment', ingredients: ['toxin'], sell: 6, rarity: 'uncommon', consume: { type: 'bankGoldNext', text: 'Lose up to 15 Gold now; gain double that next round', cap: 15, multiplier: 2 } },

      // Two-ingredient staples (mana/health base, rares augment)
      { id: 'mana_flame', name: 'Sparkshot Elixir', ingredients: ['mana', 'flame'], sell: recipeSell(['mana', 'flame']), consume: { type: 'boost', text: '+2 Gold per die next roll', perDie: 2 } },
      { id: 'health_flame', name: 'Cinder Guard', ingredients: ['health', 'flame'], sell: recipeSell(['health', 'flame'], 1), consume: { type: 'reroll', text: 'Gain 3 shop reroll tokens (refresh shop)', rerolls: 3 } },
      { id: 'mana_essence', name: 'Arcane Charge', ingredients: ['mana', 'essence'], sell: recipeSell(['mana', 'essence']), consume: { type: 'delayedIngredients', text: 'Gain 1 Mana and 1 Essence next roll', ingredients: ['mana', 'essence'] } },
      { id: 'health_essence', name: 'Golden Poultice', ingredients: ['health', 'essence'], sell: recipeSell(['health', 'essence']), consume: { type: 'passiveGoldPerRound', text: 'Gain +4 Gold each round for the rest of the game', amount: 4 } },
      { id: 'mana_toxin', name: 'Smokestack Veil', ingredients: ['mana', 'toxin'], sell: recipeSell(['mana', 'toxin']), consume: { type: 'randomShopItems', text: 'Gain 2 random shop items (free)', count: 2 } },
      { id: 'health_toxin', name: 'Purging Balm', ingredients: ['health', 'toxin'], sell: recipeSell(['health', 'toxin']), consume: { type: 'convertIngredients', text: 'Next roll: each toxin becomes 2 essence', from: 'toxin', to: 'essence', multiplier: 2 } },

      // Three-ingredient brews (commons with rare boosts)
      { id: 'health_mana_flame', name: 'Phoenix Aid', ingredients: ['health', 'mana', 'flame'], sell: 20, consume: { type: 'boost', text: '+3 Gold per die next roll', perDie: 3 } },
      { id: 'health_mana_essence', name: 'Aegis Brew', ingredients: ['health', 'mana', 'essence'], sell: recipeSell(['health', 'mana', 'essence'], 2), consume: { type: 'ingToGold', text: 'Next roll: each ingredient converts to 6 Gold', goldPerIng: 6 } },

      { id: 'health_mana_toxin', name: 'Ward of Thorns', ingredients: ['health', 'mana', 'toxin'], sell: recipeSell(['health', 'mana', 'toxin'], 1), consume: { type: 'tieredCoinToIng', text: 'Next roll: each gold face gives 1 ingredient based on its value (1 mana, 2 health, 3 flame, 4 toxin, 5+ essence)' } },
      { id: 'health_flame_essence', name: 'Solar Surge', ingredients: ['health', 'flame', 'essence'], sell: recipeSell(['health', 'flame', 'essence'], 3), consume: { type: 'passiveGoldPerRound', text: 'Gain +8 Gold each round for the rest of the game', amount: 8 } },
      { id: 'mana_flame_essence', name: 'Arcane Inferno', ingredients: ['mana', 'flame', 'essence'], sell: recipeSell(['mana', 'flame', 'essence'], 3), consume: { type: 'ingredientMultiplier', text: 'Flame ingredients count double permanently', ing: 'flame', multiplier: 2 } },
      { id: 'health_flame_toxin', name: 'Scorch Cleanse', ingredients: ['health', 'flame', 'toxin'], sell: recipeSell(['health', 'flame', 'toxin'], 2), consume: { type: 'potionSellBonus', text: 'Next round: potions sell for +13 Gold', amount: 13 } },
      { id: 'mana_flame_toxin', name: 'Venom Spark', ingredients: ['mana', 'flame', 'toxin'], sell: recipeSell(['mana', 'flame', 'toxin'], 2), consume: { type: 'duplicateDiceLoseRound', text: 'Next roll: duplicate all dice, lose 1 max round' } },
      { id: 'toxin_triple_coinflip', name: 'Snakebite Lottery', ingredients: ['toxin', 'toxin', 'toxin'], sell: recipeSell(['toxin', 'toxin', 'toxin'], 3), consume: { type: 'coinFlipJackpot', text: '50%: gain 100 Gold; 50%: run ends immediately', gold: 100 } },

      // High-end brews (rare-heavy)
      { id: 'flame_essence_toxin', name: "Dragon's Bane Vapor", ingredients: ['flame', 'essence', 'toxin'], sell: recipeSell(['flame', 'essence', 'toxin'], 5), consume: { type: 'dieReroll', text: 'Gain 8 die rerolls (use after rolling)', amount: 8 } },
      { id: 'essence_essence_flame_mana_health', name: 'Astral Crucible', ingredients: ['essence', 'essence', 'flame'], sell: recipeSell(['essence', 'essence', 'flame'], 4), rarity: 'rare', consume: { type: 'addDieSlot', text: 'Permanently gain +1 die slot (stacks past shop slots)' } },
      { id: 'flame_flame_essence_toxin', name: 'Hellfire Panacea', ingredients: ['flame', 'flame', 'essence', 'toxin'], sell: recipeSell(['flame', 'flame', 'essence', 'toxin'], 8), consume: { type: 'unusedIngGold', text: 'Next round: +30 Gold per unused Flame/Essence/Toxin', amount: 30, ings: ['flame', 'essence', 'toxin'] } },
      { id: 'health_mana_flame_essence', name: 'Grand Aegis', ingredients: ['health', 'mana', 'flame', 'essence'], sell: recipeSell(['health', 'mana', 'flame', 'essence'], 6), consume: { type: 'passiveGoldPerRound', text: 'Gain +15 Gold each round (permanent)', amount: 15 } },
      { id: 'health_mana_flame_toxin', name: 'Plaguefire Bulwark', ingredients: ['health', 'mana', 'flame', 'toxin'], sell: recipeSell(['health', 'mana', 'flame', 'toxin'], 7), consume: { type: 'empowerDie', text: 'Choose a die: coins x3 & ingredient rolls x2 (permanent)', goldMult: 3, ingMult: 2 } },
      { id: 'mana_flame_essence_toxin', name: 'Voidfire Draught', ingredients: ['mana', 'flame', 'essence', 'toxin'], sell: recipeSell(['mana', 'flame', 'essence', 'toxin'], 9), consume: { type: 'score', text: 'Gain 50 points immediately', amount: 50 } },
      { id: 'grand_transmutation', name: 'Grand Transmutation', ingredients: ['health', 'mana', 'flame', 'essence', 'toxin'], sell: recipeSell(['health', 'mana', 'flame', 'essence', 'toxin'], 12), consume: { type: 'sacrificeDoubleRoll', text: 'Sacrifice a die: next roll coins/ingredients doubled; lose 1 max die' } },
      { id: 'cataclysmic_surge', name: 'Cataclysmic Surge', ingredients: ['mana', 'mana', 'flame', 'essence', 'toxin'], sell: recipeSell(['mana', 'mana', 'flame', 'essence', 'toxin'], 14), consume: { type: 'goldMultiplier', text: 'Next roll: Gold faces pay 10', multiplier: 10 } },
      { id: 'philosophers_stone', name: "Philosopher's Stone", ingredients: ['health', 'health', 'mana', 'flame', 'essence', 'toxin'], sell: recipeSell(['health', 'health', 'mana', 'flame', 'essence', 'toxin'], 18), consume: { type: 'extendMaxRounds', text: 'Extend the run by +1 round (play one extra round)', amount: 1 } }
    ];

    const shopStock = [
      { id: 'tokenPack', name: 'Shop Reroll Pack', cost: 4, desc: '+2 shop reroll tokens (max 3)', consumable: false, action: (s) => { addRerollTokens(2, s); return 'Gained reroll tokens.'; } },
      { id: 'dieReroll', name: 'Die Reroll', cost: 5, desc: 'Reroll one rolled die of your choice this round', consumable: true, shopUsable: false, action: (s) => {
        if (!s.rolled || !s.currentRolls.length) return 'Roll first, then use this.';
        s.pendingDieReroll = true;
        s.dieRerollsLeft = (s.dieRerollsLeft || 0) + 1;
        return `Select a die to reroll (${s.dieRerollsLeft} left).`;
      } },
      { id: 'doubleGold', name: 'Gold Doubler', cost: 7, desc: 'Double all Gold you gain this roll', consumable: true, shopUsable: false, action: (s) => { s.statuses.push({ type: 'goldDoubler', amount: 2, expires: effectTargetRound() }); return 'Gold will be doubled this roll.'; } },
      { id: 'goldPolish', name: 'Gold Polish', cost: 4, desc: '+1 Gold per die this roll', consumable: true, shopUsable: false, preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'perDieGold', amount: 1, expires: effectTargetRound() }); return 'Each die will grant +1 Gold this roll.'; } },
      { id: 'spiceFinder', name: 'Spice Finder', cost: 4, desc: '+3 Gold per unique ingredient rolled this round', consumable: true, shopUsable: false, preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'uniqueGoldBonus', amount: 3, expires: effectTargetRound() }); return 'You will gain +3 Gold for each unique ingredient rolled.'; } },
      { id: 'spiceFinderPlus', name: 'Spicefinder Sigil', cost: 9, desc: 'Permanent: +1 Gold per unique ingredient each round', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'uniqueGoldBonus', amount: 1, expires: Infinity }); return 'Permanent: +1 Gold per unique ingredient each round.'; } },
      { id: 'doubleMana', name: 'Mana Bloom Charm', cost: 4, desc: 'Double mana ingredients gained this roll', consumable: true, shopUsable: false, category: 'doubleIng', preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'doubleIng', ing: 'mana', expires: effectTargetRound() }); return 'Mana gains will be doubled this roll.'; } },
      { id: 'doubleHealth', name: 'Herbal Infuser', cost: 4, desc: 'Double health ingredients gained this roll', consumable: true, shopUsable: false, category: 'doubleIng', preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'doubleIng', ing: 'health', expires: effectTargetRound() }); return 'Health gains will be doubled this roll.'; } },
      { id: 'doubleFlame', name: 'Flame Bellows', cost: 4, desc: 'Double flame ingredients gained this roll', consumable: true, shopUsable: false, category: 'doubleIng', preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'doubleIng', ing: 'flame', expires: effectTargetRound() }); return 'Flame gains will be doubled this roll.'; } },
      { id: 'doubleEssence', name: 'Essence Prism', cost: 5, desc: 'Double essence ingredients gained this roll', consumable: true, shopUsable: false, category: 'doubleIng', preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'doubleIng', ing: 'essence', expires: effectTargetRound() }); return 'Essence gains will be doubled this roll.'; } },
      { id: 'doubleToxin', name: 'Toxin Splitter', cost: 3, desc: 'Double toxin ingredients gained this roll', consumable: true, shopUsable: false, category: 'doubleIng', preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'doubleIng', ing: 'toxin', expires: effectTargetRound() }); return 'Toxin gains will be doubled this roll.'; } },
      { id: 'steadyMintShot', name: 'Steady Minting (Shot)', cost: 5, desc: 'This round: +4 Gold on each gold face', consumable: true, shopUsable: false, preRollOnly: true, action: (s) => { if (s.rolled) return 'Use before rolling.'; s.statuses.push({ type: 'goldFaceBonus', amount: 4, expires: effectTargetRound() }); return 'Gold faces will each gain +4 this roll.'; } },
      { id: 'steadyMint', name: 'Steady Minting', cost: 9, desc: 'Permanent: +1 Gold for every gold face each roll', consumable: false, permanent: true, rarity: 'uncommon', action: (s) => { s.statuses.push({ type: 'passiveGoldOnGold', amount: 1 }); return 'Passive unlocked: +1 Gold on every gold face each round.'; } },
      { id: 'manaEcho', name: 'Mana Echo', cost: 5, desc: 'If you roll no Mana, gain 1 Mana automatically', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'passiveManaFloor', amount: 1 }); return 'Passive unlocked: gain 1 Mana when none is rolled.'; } },
      { id: 'coinFloor', name: 'Coin Floor', cost: 7, desc: 'If your roll makes <5 Gold, top it up to 5', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'passiveGoldFloor', floor: 5, threshold: 5 }); return 'Passive unlocked: low rolls are raised to 5 Gold.'; } },
      { id: 'goldPolish1', name: 'Gilded Polish I', cost: 2, desc: 'Upgrade a gold face: +1 Gold', consumable: true, shopUsable: false, autoUseOnPurchase: true, action: (s) => {
        if (s.pendingFacePurchase || s.pendingFaceRemoval || s.pendingFaceUpgrade) return 'Finish your current face action first.';
        s.pendingFaceUpgrade = { type: 'gold', delta: 1 };
        return 'Select a gold face to upgrade (+1 Gold).';
      } },
      { id: 'goldPolish2', name: 'Gilded Polish II', cost: 4, desc: 'Upgrade a gold face: +2 Gold', consumable: true, shopUsable: false, autoUseOnPurchase: true, rarity: 'uncommon', action: (s) => {
        if (s.pendingFacePurchase || s.pendingFaceRemoval || s.pendingFaceUpgrade) return 'Finish your current face action first.';
        s.pendingFaceUpgrade = { type: 'gold', delta: 2 };
        return 'Select a gold face to upgrade (+2 Gold).';
      } },
      { id: 'goldPolish3', name: 'Gilded Polish III', cost: 6, desc: 'Upgrade a gold face: +3 Gold', consumable: true, shopUsable: false, autoUseOnPurchase: true, rarity: 'rare', action: (s) => {
        if (s.pendingFacePurchase || s.pendingFaceRemoval || s.pendingFaceUpgrade) return 'Finish your current face action first.';
        s.pendingFaceUpgrade = { type: 'gold', delta: 3 };
        return 'Select a gold face to upgrade (+3 Gold).';
      } },
      { id: 'goldPolish4', name: 'Gilded Polish IV', cost: 8, desc: 'Upgrade a gold face: +4 Gold', consumable: true, shopUsable: false, autoUseOnPurchase: true, rarity: 'legendary', action: (s) => {
        if (s.pendingFacePurchase || s.pendingFaceRemoval || s.pendingFaceUpgrade) return 'Finish your current face action first.';
        s.pendingFaceUpgrade = { type: 'gold', delta: 4 };
        return 'Select a gold face to upgrade (+4 Gold).';
      } },
      { id: 'goldPolish5', name: 'Gilded Polish V', cost: 10, desc: 'Upgrade a gold face: +5 Gold', consumable: true, shopUsable: false, autoUseOnPurchase: true, rarity: 'mythic', action: (s) => {
        if (s.pendingFacePurchase || s.pendingFaceRemoval || s.pendingFaceUpgrade) return 'Finish your current face action first.';
        s.pendingFaceUpgrade = { type: 'gold', delta: 5 };
        return 'Select a gold face to upgrade (+5 Gold).';
      } },
      { id: 'characterReselect', name: 'Fateweaver Sigil', cost: 14, desc: 'Very rare: immediately redraw 3 characters and pick one (replaces current)', consumable: false, rarity: 'mythic', action: (s) => {
        pickCharacterDraft();
        s.pendingCharacterReselect = true;
        s.prevViewBeforeCharacter = s.view || 'shop';
        setView('character');
        renderCharacterSelect();
        return 'Choose a new character to replace your current one.';
      } },
      { id: 'doubleHerb', name: 'Essence of Plenty', cost: 6, desc: 'Upgrade an ingredient face to a double ingredient', consumable: true, shopUsable: false, autoUseOnPurchase: true, rarity: 'rare', action: (s) => {
        if (s.pendingFacePurchase || s.pendingFaceRemoval || s.pendingFaceUpgrade) return 'Finish your current face action first.';
        s.pendingFaceUpgrade = { type: 'doubleIngredient' };
        return 'Select an ingredient face to make it yield 2.';
      } },
      { id: 'shopRerollBoost', name: 'Shop Expansion', cost: 7, desc: 'Increase max shop rerolls by +1 each round', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'shopRerollMaxBonus', amount: 1 }); return 'Passive unlocked: +1 max shop reroll each round.'; } },
      { id: 'steadyDieReroll', name: 'Steady Hand', cost: 9, desc: 'Gain 1 die reroll every round (auto-refresh)', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'passiveDieReroll', amount: 1 }); return 'Passive unlocked: +1 die reroll each round.'; } },
      { id: 'firstHealthDoubler', name: 'Vital Surge Sigil', cost: 11, desc: 'Permanent: first Health rolled each round is doubled', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'firstIngDoubler', ing: 'health', usedAtRound: 0 }); return 'Permanent: first Health each round is doubled.'; } },
      { id: 'firstManaDoubler', name: 'Aether Echo Sigil', cost: 11, desc: 'Permanent: first Mana rolled each round is doubled', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'firstIngDoubler', ing: 'mana', usedAtRound: 0 }); return 'Permanent: first Mana each round is doubled.'; } },
      { id: 'firstFlameDoubler', name: 'Ember Surge Sigil', cost: 11, desc: 'Permanent: first Flame rolled each round is doubled', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'firstIngDoubler', ing: 'flame', usedAtRound: 0 }); return 'Permanent: first Flame each round is doubled.'; } },
      { id: 'firstEssenceDoubler', name: 'Auric Echo Sigil', cost: 11, desc: 'Permanent: first Essence rolled each round is doubled', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'firstIngDoubler', ing: 'essence', usedAtRound: 0 }); return 'Permanent: first Essence each round is doubled.'; } },
      { id: 'firstToxinDoubler', name: 'Vile Echo Sigil', cost: 11, desc: 'Permanent: first Toxin rolled each round is doubled', consumable: false, permanent: true, action: (s) => { s.statuses.push({ type: 'firstIngDoubler', ing: 'toxin', usedAtRound: 0 }); return 'Permanent: first Toxin each round is doubled.'; } },
      
    ];

    const itemIds = shopStock.map((i) => i.id);
    const dieTypeIds = diceCatalog.map((d) => d.id);
    const faceKeys = [
      'gold2', 'gold3', 'gold4', 'gold5',
      'ing_health', 'ing_mana', 'ing_flame', 'ing_essence', 'ing_toxin',
      'ing2_mana', 'ing2_flame', 'ing2_toxin',
      'eff_doubleGoldAll', 'eff_doubleHighestGold', 'eff_copyIngredient', 'eff_wildIngredient', 'eff_boostGold', 'eff_goldAura', 'eff_purgeFace',
      'eff_doubleIng_health', 'eff_doubleIng_mana', 'eff_doubleIng_flame', 'eff_doubleIng_essence', 'eff_doubleIng_toxin',
      'eff_score15',
      'blank'
    ];

    function ensureToggleDefaults() {
      if (!settings.enabledItems) {
        settings.enabledItems = Object.fromEntries(itemIds.map((id) => [id, true]));
      }
      if (!settings.enabledDiceTypes) {
        settings.enabledDiceTypes = Object.fromEntries(dieTypeIds.map((id) => [id, true]));
      }
      if (!settings.enabledFaces) {
        settings.enabledFaces = Object.fromEntries(faceKeys.map((k) => [k, true]));
      }
      itemIds.forEach((id) => {
        if (settings.enabledItems[id] === undefined) settings.enabledItems[id] = true;
      });
      dieTypeIds.forEach((id) => {
        if (settings.enabledDiceTypes[id] === undefined) settings.enabledDiceTypes[id] = true;
      });
      faceKeys.forEach((k) => {
        if (settings.enabledFaces[k] === undefined) settings.enabledFaces[k] = true;
      });
    }

    const makeDie = (typeId) => ({ id: `die-${Math.random().toString(36).slice(2)}`, typeId });

    const characterClasses = [
      {
        id: 'witch',
        name: 'Witch Brewer',
        desc: '+1 max die slot and start with a reroll token.',
        apply: (s) => {
          s.maxDice += 1;
          addRerollTokens(1, s);
        }
      },
      {
        id: 'battle_mage',
        name: 'Battle Mage',
        desc: 'Begin with a Goldsmith Die in place of your first apprentice die.',
        apply: (s) => {
          const goldsmithDie = makeDie('goldsmith');
          if (s.dice.length) {
            s.dice[0] = goldsmithDie;
          } else {
            s.dice.push(goldsmithDie);
          }
        }
      },
      {
        id: 'occultist',
        name: 'Occultist',
        desc: 'Gold earned above 5 each round is doubled.',
        apply: (s) => {
          s.statuses.push({ type: 'excessGoldDouble', threshold: 5 });
        }
      },
      {
        id: 'merchant',
        name: 'Street Merchant',
        desc: 'Shop rerolls are free.',
        apply: (s) => {
          s.statuses.push({ type: 'cheapShopReroll', cost: 0 });
        }
      },
      {
        id: 'chronomancer',
        name: 'Chronomancer',
        desc: 'Play one extra round (+1 max rounds).',
        apply: (s) => {
          s.maxRounds = Math.min(99, s.maxRounds + 1);
        }
      },
      {
        id: 'artificer',
        name: 'Artificer',
        desc: 'Permanent +1 Gold on every gold face.',
        apply: (s) => {
          s.statuses.push({ type: 'passiveGoldOnGold', amount: 1 });
        }
      },
      {
        id: 'reroll_savant',
        name: 'Reroll Savant',
        desc: 'Start with 10 die rerolls queued for round 1.',
        apply: (s) => {
          s.statuses.push({ type: 'dieRerollToken', amount: 10, expires: s.round });
        }
      },
      {
        id: 'scrap_alchemist',
        name: 'Scrap Alchemist',
        desc: 'Each round: purge 1 random face, upgrade another (coins +2, ingredients +1).',
        apply: (s) => {
          s.statuses.push({ type: 'purgeUpgrade', goldDelta: 2, ingDelta: 1 });
        }
      },
      {
        id: 'bazaar_broker',
        name: 'Bazaar Broker',
        desc: 'Potions sell for +4 Gold permanently.',
        apply: (s) => {
          s.statuses.push({ type: 'potionSellPassive', amount: 4 });
        }
      },
      {
        id: 'ingredient_scholar',
        name: 'Ingredient Scholar',
        desc: '+2 points whenever you roll an ingredient.',
        apply: (s) => {
          s.statuses.push({ type: 'ingredientPoints', amount: 2 });
        }
      }
    ];

    function freshState() {
      const startDice = clamp(settings.startingDice, 1, 9);
      const startGold = Math.max(0, Math.floor(settings.startingGold));
      const rounds = clamp(settings.maxRounds, 1, 99);
      return {
        round: 1,
        maxRounds: rounds,
        maxDice: Math.max(6, startDice),
        extraSlotsBought: 0,
        gold: startGold,
        dice: Array.from({ length: startDice }, () => makeDie('apprentice')),
        ingredients: [],
        potions: [],
        statuses: [],
        effectNotes: [],
        tokens: { reroll: 0, removeFace: 0 },
        shopRerollsLeft: 3,
        items: [],
        currentRolls: [],
        rollSnapshot: null,
        pendingDieReroll: false,
        pendingDieSacrifice: null,
        pendingDieEmpower: null,
        pendingDiePurchase: null,
        pendingFacePurchase: null,
        pendingFaceUpgrade: null,
        knowledge: false,
        rolled: false,
        cauldron: [],
        shopOffers: sampleShopOffers(),
        diceShopOffers: sampleDiceOffers(),
        faceShopOffers: sampleFaceOffers(),
        stats: {
          potionsBrewed: 0,
          potionsConsumed: 0,
          potionValue: 0,
          itemsBought: 0,
          score: 0,
          ingredients: { health: 0, mana: 0, flame: 0, essence: 0, toxin: 0 }
        },
        view: 'start',
        character: null,
        pendingCharacterReselect: false,
        prevViewBeforeCharacter: 'start'
      };
    }

    loadSettingsFromStorage();
    loadLifetimeStatsFromStorage();

    let state = freshState();

    const els = {
      roundLabel: document.getElementById('roundLabel'),
      goldLabel: document.getElementById('goldLabel'),
      scoreLabel: document.getElementById('scoreLabel'),
      progressBar: document.getElementById('progressBar'),
      diceRow: document.getElementById('diceRow'),
      ingredientsRow: document.getElementById('ingredientsRow'),
      cauldronRow: document.getElementById('cauldronRow'),
      potionsList: document.getElementById('potionsList'),
      shopList: document.getElementById('shopList'),
      diceInventoryList: document.getElementById('diceInventoryList'),
      potionInventoryList: document.getElementById('potionInventoryList'),
      itemInventoryList: document.getElementById('itemInventoryList'),
      itemInventoryRoll: document.getElementById('itemInventoryRoll'),
      invRound: document.getElementById('invRound'),
      invGold: document.getElementById('invGold'),
      invDiceLabel: document.getElementById('invDice'),
      brewBtn: document.getElementById('brewBtn'),
      clearCauldron: document.getElementById('clearCauldron'),
      autoBrewBtn: document.getElementById('autoBrewBtn'),
      diceShopList: document.getElementById('diceShopList'),
      recipeBook: document.getElementById('recipeBook'),
      recipeModal: document.getElementById('recipeModalWrapper'),
      invalidBrewModal: document.getElementById('invalidBrewModal'),
      closeInvalidBrew: document.getElementById('closeInvalidBrew'),
      statsModal: document.getElementById('statsModal'),
      lifetimeStats: document.getElementById('lifetimeStats'),
      lifetimeBlock: document.getElementById('lifetimeBlock'),
      closeStats: document.getElementById('closeStats'),
      gameOverModal: document.getElementById('gameOverModal'),
      gameOverStats: document.getElementById('gameOverStats'),
      closeGameOver: document.getElementById('closeGameOver'),
      rerollShop: document.getElementById('rerollShop'),
      openRecipeBook: document.getElementById('openRecipeBook'),
      closeRecipeBook: document.getElementById('closeRecipeBook'),
      startScreen: document.getElementById('startScreen'),
      startIntro: document.getElementById('startIntro'),
      characterSelectView: document.getElementById('characterSelectView'),
      playView: document.getElementById('playView'),
      rollStage: document.getElementById('rollStage'),
      shopStage: document.getElementById('shopStage'),
      startGameBtn: document.getElementById('startGameBtn'),
      chooseCharacterBtn: document.getElementById('chooseCharacterBtn'),
      startRecipeBtn: document.getElementById('startRecipeBtn'),
      startStatsBtn: document.getElementById('startStatsBtn'),
      startSettingsBtn: document.getElementById('startSettingsBtn'),
      startHowToBtn: document.getElementById('startHowToBtn'),
      howToPlay: document.getElementById('howToPlay'),
      toShopBtn: document.getElementById('toShopBtn'),
      backToBrew: document.getElementById('backToBrew'),
      statusRow: document.getElementById('statusRow'),
      log: document.getElementById('log'),
      rollBtn: document.getElementById('rollBtn'),
      nextBtn: document.getElementById('nextBtn'),
      sellAllShop: document.getElementById('sellAllShop'),
      faceShopList: document.getElementById('faceShopList'),
      settingsModal: document.getElementById('settingsModal'),
      closeSettings: document.getElementById('closeSettings'),
      saveSettings: document.getElementById('saveSettings'),
      resetSettings: document.getElementById('resetSettings'),
      settingStartingDice: document.getElementById('settingStartingDice'),
      settingStartingGold: document.getElementById('settingStartingGold'),
      settingMaxRounds: document.getElementById('settingMaxRounds'),
      settingShopSlots: document.getElementById('settingShopSlots'),
      settingItemToggles: document.getElementById('settingItemToggles'),
      settingDieToggles: document.getElementById('settingDieToggles'),
      settingDiceToggles: document.getElementById('settingDiceToggles'),
      extraSlotRow: document.getElementById('extraSlotRow'),
      extraSlotLabel: document.getElementById('extraSlotLabel'),
      buyExtraSlotBtn: document.getElementById('buyExtraSlotBtn'),
      characterGrid: document.getElementById('characterGrid')
    };

    let selectedCharacterId = null;
    let characterDraft = [];
    let pendingCharacterReselect = false;
    let prevViewBeforeCharacter = 'start';


    function clamp(val, min, max) {
      return Math.min(max, Math.max(min, val));
    }

    function gainGold(amount) {
      if (!amount || amount <= 0) return;
      state.gold += amount;
      state.stats.score += amount;
    }

    function potionSellBonusForRound() {
      const roundBonus = state.statuses
        .filter((s) => s.type === 'potionSellBonus' && s.expires === state.round)
        .reduce((sum, s) => sum + (s.amount || 0), 0);
      const passiveBonus = state.statuses
        .filter((s) => s.type === 'potionSellPassive')
        .reduce((sum, s) => sum + (s.amount || 0), 0);
      return roundBonus + passiveBonus;
    }

    function addRerollTokens(amount, targetState = state) {
      if (!targetState || !amount || amount <= 0) return;
      targetState.tokens.reroll = Math.min(3, targetState.tokens.reroll + amount);
    }

    function shopRerollCost() {
      const discount = state.statuses.find((s) => s.type === 'cheapShopReroll');
      return discount && discount.cost !== undefined ? Math.max(0, discount.cost) : 3;
    }

    function applyExcessGoldBonus(goldBefore) {
      const eff = state.statuses.find((s) => s.type === 'excessGoldDouble');
      if (!eff) return;
      const gained = state.gold - goldBefore;
      const threshold = eff.threshold !== undefined ? eff.threshold : 5;
      const over = gained - threshold;
      if (over > 0) {
        gainGold(over);
        log(`Passive: doubled ${over} Gold above ${threshold}.`);
      }
    }

    function grantShopItem(item) {
      if (!item) return null;
      if (item.consumable) {
        const entry = {
          id: `${item.id}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`,
          name: item.name,
          desc: item.desc,
          action: item.action,
          shopUsable: item.shopUsable !== false,
          preRollOnly: true,
          rarity: item.rarity || itemRarity(item)
        };
        state.items.push(entry);
        return `Added ${item.name} to inventory.`;
      }
      const result = item.action(state);
      return result || `Applied ${item.name}.`;
    }

    function pickCharacterDraft() {
      characterDraft = shuffle(characterClasses).slice(0, 3);
      selectedCharacterId = characterDraft[0] ? characterDraft[0].id : (characterClasses[0] ? characterClasses[0].id : null);
    }

    function renderCharacterSelect() {
      if (!els.characterGrid || !characterClasses.length) return;
      if (!characterDraft.length) pickCharacterDraft();
      if (!selectedCharacterId && characterDraft[0]) selectedCharacterId = characterDraft[0].id;
      els.characterGrid.innerHTML = '';
      characterDraft.forEach((c) => {
        const card = document.createElement('div');
        card.className = `character-card${selectedCharacterId === c.id ? ' selected' : ''}`;
        card.innerHTML = `<h3>${c.name}</h3><div class="meta">${c.desc}</div>`;
        card.onclick = () => {
          selectedCharacterId = c.id;
          renderCharacterSelect();
        };
        els.characterGrid.appendChild(card);
      });
    }

    function rarityClass(rarity) {
      return rarity ? `rarity-${rarity}` : '';
    }

    function getRecipeById(id) {
      return recipes.find((r) => r.id === id);
    }

    function potionRarity(potion) {
      const recipe = getRecipeById(potion.id) || potion;
      if (recipe && recipe.rarity) return recipe.rarity;
      const ingredients = Array.isArray(recipe.ingredients) ? recipe.ingredients : [];
      const ingCount = ingredients.length || 1;
      const rareIngs = ['flame', 'essence', 'toxin'];
      const rareCount = ingredients.filter((i) => rareIngs.includes(i)).length;

      const clampTier = (t) => Math.max(0, Math.min(4, t));
      const tierToName = (t) => ['common', 'uncommon', 'rare', 'legendary', 'mythic'][clampTier(t)];

      let tier = 0; // 0=common, 1=uncommon, 2=rare, 3=legendary, 4=mythic
      if (ingCount <= 1) {
        tier = 0;
      } else if (ingCount === 2) {
        tier = rareCount > 0 ? 1 : 0;
      } else if (ingCount === 3) {
        tier = 1 + (rareCount > 0 ? 1 : 0);
      } else {
        tier = 2 + (rareCount > 0 ? 1 : 0); // 4 ingredients start one tier higher
        tier += Math.max(0, ingCount - 4); // 5+ ingredients step up further
      }

      return tierToName(tier);
    }

    function itemRarity(item) {
      const cost = item.cost || 0;
      if (cost >= 11) return 'mythic';
      if (cost >= 9) return 'legendary';
      if (cost >= 7) return 'rare';
      if (cost >= 5) return 'uncommon';
      return 'common';
    }

    function rarityWeight(rarity) {
      switch (rarity) {
        case 'mythic': return 0.05;
        case 'legendary': return 0.1;
        case 'rare': return 0.25;
        case 'uncommon': return 0.6;
        default: return 1.5;
      }
    }

    function highestFaceRarity(faces, costHint = 0) {
      if (!faces || !faces.length) return 'common';
      const rank = { common: 0, uncommon: 1, rare: 2, legendary: 3, mythic: 4 };
      let best = 'common';
      faces.forEach((f) => {
        const r = faceRarity(f, costHint);
        if (rank[r] > rank[best]) best = r;
      });
      return best;
    }

    function dieRarity(def, overrideFaces = null) {
      if (!def && !overrideFaces) return 'common';
      const faces = overrideFaces || (def && def.faces) || [];
      if (faces.length) return highestFaceRarity(faces, def ? def.price || 0 : 0);
      const price = def && def.price ? def.price : 0;
      if (price >= 11) return 'mythic';
      if (price >= 9) return 'legendary';
      if (price >= 7) return 'rare';
      if (price >= 5) return 'uncommon';
      return 'common';
    }

    function faceRarity(face, cost = 0) {
      if (!face) return 'common';
      if (face.kind === 'effect') {
        if (face.effect === 'scorePoints') return 'legendary';
        if (face.effect === 'doubleGoldAll') return 'mythic';
        if (face.effect === 'doubleHighestGold') return 'legendary';
        if (face.effect === 'doubleIngredient') return 'rare';
        return 'rare';
      }
      if (face.kind === 'gold') {
        if (face.gold >= 5) return 'legendary';
        if (face.gold >= 4) return 'rare';
        if (face.gold >= 3) return 'uncommon';
        return 'common';
      }
      if (face.kind === 'ingredient') {
        return cost >= 4 ? 'uncommon' : 'common';
      }
      return 'common';
    }

    function faceRarityClass(face, cost = 0) {
      return rarityClass(faceRarity(face, cost));
    }

    function getDieDef(typeId) {
      return diceRegistry[typeId] || diceRegistry.apprentice;
    }

    function getDieFaces(die) {
      const def = getDieDef(die.typeId);
      if (die.faces && Array.isArray(die.faces) && die.faces.length) {
        return die.faces;
      }
      return def ? def.faces : [];
    }

    function dieModifiers(die) {
      if (!die) return [];
      return state.statuses.filter((s) => s.type === 'dieMod' && s.dieId === die.id);
    }

    function cloneFace(face) {
      return { ...face };
    }

    function cloneFaces(faces) {
      return faces.map(cloneFace);
    }

    function cloneDie(die) {
      if (!die) return null;
      return {
        id: `clone-${Math.random().toString(36).slice(2)}`,
        typeId: die.typeId,
        faces: cloneFaces(getDieFaces(die))
      };
    }

    function randomFaceForDie(die) {
      const faces = getDieFaces(die);
      if (!faces || !faces.length) return null;
      return cloneFace(pick(faces));
    }

    function rollDie(die) {
      return randomFaceForDie(die);
    }

    function log(text) {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = `R${state.round}: ${text}`;
      els.log.prepend(entry);
    }

    function effectTargetRound() {
      return state.view === 'shop' ? state.round + 1 : state.round;
    }

    function setView(view) {
      state.view = view;
      const isStart = view === 'start';
      const isCharacter = view === 'character';
      const inRoll = view === 'roll';
      const inStartScreens = isStart || isCharacter;
      els.startScreen.classList.toggle('hidden', !inStartScreens);
      els.playView.classList.toggle('hidden', inStartScreens);
      els.rollStage.classList.toggle('hidden', !inRoll);
      els.shopStage.classList.toggle('hidden', inRoll);
      els.rollBtn.disabled = !inRoll || state.rolled;
      if (els.startIntro) els.startIntro.classList.toggle('hidden', !isStart);
      if (els.characterSelectView) els.characterSelectView.classList.toggle('hidden', !isCharacter);
      if (isStart && els.characterGrid && !els.characterGrid.classList.contains('hidden')) {
        els.characterGrid.classList.add('hidden');
      }
      if (isCharacter && els.characterGrid) {
        els.characterGrid.classList.remove('hidden');
      }
    }

    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    function applyEffects(rolls, summary) {
      const goldFaces = summary.goldFaces.length ? Math.max(...summary.goldFaces) : 0;
      const goldAllMult = summary.goldAllMult || 1;
      const hasShield = state.statuses.some((s) => s.type === 'shield');
      const ingredientCount = summary.ingredients.length;
      rolls.forEach(({ die, face }) => {
        if (!face || face.kind !== 'effect') return;
        switch (face.effect) {
          case 'wildIngredient': {
            const choice = pick(ingredients);
            summary.ingredients.push(choice);
            log(`Wild ingredient added: ${choice}`);
            break;
          }
          case 'doubleGoldAll': {
            summary.goldAllMult = Math.max(goldAllMult, 2);
            log('Effect: all Gold gains doubled this roll.');
            break;
          }
          case 'goldMultiplier': {
            const mult = face.multiplier && face.multiplier > 0 ? face.multiplier : 1;
            state.statuses.push({ type: 'goldMultiplier', amount: mult, expires: effectTargetRound() });
            log(`Next roll: gold faces pay x${mult}.`);
            break;
          }
          case 'boostGold': {
            const gain = ingredientCount * goldAllMult;
            gainGold(gain);
            (summary.notes || state.effectNotes || []).push(`Boost Gold effect: +${gain} Gold (+1 per ingredient)`);
            log(`Effect: gained ${gain} Gold (per ingredient, ${ingredientCount} ingredients${goldAllMult > 1 ? ', doubled' : ''}).`);
            break;
          }
          case 'goldAura': {
            let boosted = 0;
            rolls.forEach(({ die: d, face: f }) => {
              if (!d || f.kind !== 'gold') return;
              const faces = cloneFaces(getDieFaces(d));
              let idx = faces.findIndex((cf) => JSON.stringify(cf) === JSON.stringify(f));
              if (idx < 0) idx = faces.findIndex((cf) => cf.kind === 'gold');
              if (idx < 0) return;
              const target = faces[idx];
              const newGold = (target.gold || 0) + 1;
              faces[idx] = { ...target, gold: newGold, label: `Coins +${newGold}` };
              d.faces = faces;
              boosted += 1;
            });
            log(`Effect: gilded ${boosted} rolled gold face${boosted === 1 ? '' : 's'} (+1).`);
            break;
          }
          case 'doubleHighestGold': {
            const boost = goldFaces * goldAllMult;
            gainGold(boost);
            (summary.notes || state.effectNotes || []).push(`Double highest gold: +${boost} Gold`);
            log(`Effect: doubled highest gold (+${boost}${goldAllMult > 1 ? ', doubled' : ''}).`);
            break;
          }
          case 'purgeFace': {
            const candidates = rolls.filter((r) => r.face !== face && getDieFaces(r.die).length > 1);
            if (!candidates.length) {
              log('Purge: no other rolled face can be purged (all single-face dice).');
              break;
            }
            const target = pick(candidates);
            const faces = cloneFaces(getDieFaces(target.die));
            if (faces.length <= 1) {
              log('Purge: target die cannot lose a face.');
              break;
            }
            let idx = faces.findIndex((f) => JSON.stringify(f) === JSON.stringify(target.face));
            if (idx < 0) idx = faces.length - 1;
            faces.splice(idx, 1);
            target.die.faces = faces;
            log(`Purge: removed a face from ${getDieDef(target.die.typeId)?.name || 'a die'}. It now has ${faces.length} face${faces.length === 1 ? '' : 's'}.`);
            break;
          }
          case 'doubleIngredient': {
            const targetIng = face.ing || pick(ingredients) || 'mana';
            state.statuses.push({ type: 'doubleIng', ing: targetIng, expires: effectTargetRound() });
            log(`Effect: ${targetIng} gains doubled this roll.`);
            break;
          }
          case 'scorePoints': {
            const amt = face.amount !== undefined ? face.amount : 15;
            state.stats.score += amt;
            log(`Effect: gained ${amt} points.`);
            break;
          }
          case 'copyIngredient': {
            if (summary.ingredients.length === 0) break;
            const copy = pick(summary.ingredients);
            summary.ingredients.push(copy);
            log(`Effect: copied ingredient ${copy}.`);
            break;
          }
          case 'toxin': {
            if (hasShield) {
              log('Toxin blocked by shield.');
              state.statuses = state.statuses.filter((s) => s.type !== 'shield');
              break;
            }
            state.gold = Math.max(0, state.gold - 2);
            log('Toxin: lost 2 Gold.');
            break;
          }
          default:
            break;
        }
      });
    }

    function addToCauldron(ing) {
      const idx = state.ingredients.indexOf(ing);
      if (idx === -1) return;
      state.ingredients.splice(idx, 1);
      state.cauldron.push(ing);
      render();
    }

    function removeFromCauldron(idx) {
      const ing = state.cauldron[idx];
      if (ing === undefined) return;
      state.cauldron.splice(idx, 1);
      state.ingredients.push(ing);
      render();
    }

    function clearCauldronContents() {
      state.ingredients.push(...state.cauldron);
      state.cauldron = [];
      render();
    }

    function sameMultiset(a, b) {
      if (a.length !== b.length) return false;
      const sortedA = [...a].sort();
      const sortedB = [...b].sort();
      for (let i = 0; i < sortedA.length; i += 1) {
        if (sortedA[i] !== sortedB[i]) return false;
      }
      return true;
    }

    function brewCauldron() {
      if (!state.cauldron.length) {
        log('Cauldron is empty.');
        return;
      }
      const match = recipes.find((r) => sameMultiset(r.ingredients, state.cauldron));
      if (!match) {
        log('Recipe invalid. No potion brewed.');
        showInvalidBrew();
        return;
      }
      state.potions.push({ id: match.id, name: match.name, sell: match.sell, consume: match.consume });
      recordPotionBrew(match);
      state.cauldron = [];
      log(`Brewed ${match.name}.`);
      render();
    }

    function canBrewWithCounts(recipe, counts) {
      return recipe.ingredients.every((ing) => counts[ing] && counts[ing] > 0 && (() => { counts[ing] -= 1; return true; })());
    }

    function autoBrew() {
      if (!state.ingredients.length) { log('No ingredients to auto brew.'); return; }
      const counts = {};
      state.ingredients.forEach((ing) => { counts[ing] = (counts[ing] || 0) + 1; });
      const brewed = [];
      const sortedRecipes = [...recipes].sort((a, b) => b.sell - a.sell);
      let made = true;
      while (made) {
        made = false;
        for (const r of sortedRecipes) {
          const snapshot = { ...counts };
          if (canBrewWithCounts(r, counts)) {
            brewed.push(r);
            made = true;
            break;
          }
          Object.assign(counts, snapshot);
        }
      }
      if (!brewed.length) { log('No valid recipes to auto brew.'); return; }
      // Rebuild ingredient list from remaining counts
      const remaining = [];
      Object.entries(counts).forEach(([ing, n]) => {
        for (let i = 0; i < n; i += 1) remaining.push(ing);
      });
      state.ingredients = remaining;
      brewed.forEach((r) => {
        state.potions.push({ id: r.id, name: r.name, sell: r.sell, consume: r.consume });
        recordPotionBrew(r);
        log(`Auto brewed ${r.name}.`);
      });
      render();
    }

    function renderDice(rolls) {
      els.diceRow.innerHTML = '';
      if (!rolls.length) {
        els.diceRow.innerHTML = '<div class="empty">No rolls yet.</div>';
        return;
      }
      rolls.forEach((entry, idx) => {
        const { face, die } = entry;
        const type = getDieDef(die.typeId);
        const card = document.createElement('div');
        const rarityCls = faceRarityClass(face);
        card.className = `die-card ${rarityCls}${state.pendingDieReroll ? ' reroll-ready' : ''}`.trim();
        if (state.pendingDieReroll) {
          card.style.cursor = 'pointer';
          card.title = 'Click to reroll this die';
          card.onclick = () => rerollDieAt(idx);
        }
        card.innerHTML = `
          <div class="pill-row">
            <span class="badge">Die ${idx + 1}</span>
            <span class="tag ${face.tag}">${face.kind === 'ingredient' ? face.ingredient : face.tag}</span>
          </div>
          <strong>${face.label}</strong>
          <div class="hint">${face.kind === 'gold' ? `Coins +${face.gold} (instant)` : ''}</div>
          <div class="hint">${type ? type.name : ''}</div>
        `;
        els.diceRow.appendChild(card);
      });
    }

    function renderIngredients() {
      els.ingredientsRow.innerHTML = '';
      if (!state.ingredients.length) {
        els.ingredientsRow.innerHTML = '<div class="empty">No loose ingredients.</div>';
        return;
      }
      const counts = {};
      state.ingredients.forEach((ing) => { counts[ing] = (counts[ing] || 0) + 1; });
      ingredients.forEach((ing) => {
        if (!counts[ing]) return;
        const row = document.createElement('div');
        row.className = 'list-item';
        row.innerHTML = `<div><strong>${ing}</strong><div class="meta">Available: ${counts[ing]}</div></div>`;
        const btn = document.createElement('button');
        btn.textContent = 'Add to Cauldron';
        btn.onclick = () => addToCauldron(ing);
        row.appendChild(btn);
        els.ingredientsRow.appendChild(row);
      });
    }

    function renderCauldron() {
      els.cauldronRow.innerHTML = '';
      if (!state.cauldron.length) {
        els.cauldronRow.innerHTML = '';
        return;
      }
      state.cauldron.forEach((ing, idx) => {
        const pill = document.createElement('span');
        pill.className = `tag ${ing}`;
        pill.textContent = ing;
        pill.style.cursor = 'pointer';
        pill.title = 'Click to remove from cauldron';
        pill.onclick = () => removeFromCauldron(idx);
        els.cauldronRow.appendChild(pill);
      });
    }

    function renderPotions() {
      els.potionsList.innerHTML = '';
      if (!state.potions.length) {
        els.potionsList.innerHTML = '<div class="empty">No potions brewed yet.</div>';
        if (els.sellAllShop) els.sellAllShop.disabled = true;
        return;
      }

      if (els.sellAllShop) {
        if (state.stage === 'roll') {
          els.sellAllShop.disabled = true;
        } else {
          els.sellAllShop.disabled = false;
        }
      }

      state.potions.forEach((p) => {
        const row = document.createElement('div');
        const rarity = potionRarity(p);
        row.className = `list-item ${rarityClass(rarity)}`.trim();
        row.innerHTML = `<div><strong>${p.name}</strong><div class="meta">Sell ${p.sell}  Consume: ${p.consume.text}</div></div>`;
        els.potionsList.appendChild(row);
      });
    }

    function renderRecipeBook() {
      els.recipeBook.innerHTML = '';
      recipes.forEach((r) => {
        const row = document.createElement('div');
        const rarity = potionRarity(r);
        row.className = `list-item ${rarityClass(rarity)}`.trim();
        const ingRow = document.createElement('div');
        ingRow.className = 'pill-row';
        r.ingredients.forEach((i) => {
          const chip = document.createElement('span');
          chip.className = `tag ${i}`;
          chip.textContent = i;
          ingRow.appendChild(chip);
        });
        const info = document.createElement('div');
        info.innerHTML = `<strong>${r.name}</strong><div class="meta">Sell: ${r.sell} | Effect: ${r.consume.text}</div>`;
        row.appendChild(info);
        row.appendChild(ingRow);
        els.recipeBook.appendChild(row);
      });
    }

    function openRecipe() {
      renderRecipeBook();
      els.recipeModal.classList.remove('hidden');
    }

    function closeRecipe() {
      els.recipeModal.classList.add('hidden');
    }

    function showInvalidBrew() {
      els.invalidBrewModal.classList.remove('hidden');
    }

    function hideInvalidBrew() {
      els.invalidBrewModal.classList.add('hidden');
    }

    function renderStatsBlock(data, target, titleSuffix) {
      target.innerHTML = '';
      if (!data) {
        target.innerHTML = '<div class="empty">No data yet.</div>';
        return;
      }
      const list = document.createElement('div');
      list.className = 'list';
      const entries = [];
      if (data.score !== undefined) entries.push({ label: 'Score', value: data.score });
      entries.push(
        { label: 'Potions brewed', value: data.potionsBrewed },
        { label: 'Potions consumed', value: data.potionsConsumed },
        { label: 'Total potion value', value: data.potionValue },
        { label: 'Items bought', value: data.itemsBought }
      );
      if (data.gamesPlayed !== undefined) {
        entries.unshift({ label: 'Games played', value: data.gamesPlayed });
      }
      if (data.highScore !== undefined) {
        entries.push({ label: 'High score', value: data.highScore });
      }
      entries.forEach((row) => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.innerHTML = `<div><strong>${row.label}${titleSuffix || ''}</strong><div class="meta">${row.value || 0}</div></div>`;
        list.appendChild(item);
      });
      const ing = document.createElement('div');
      ing.className = 'list-item';
      target.appendChild(list);
    }

    function openStatsModal() {
      renderStatsBlock(lifetimeStats, els.lifetimeStats, '');
      els.statsModal.classList.remove('hidden');
    }

    function sampleShopOffers() {
      ensureToggleDefaults();
      const slots = clamp(settings.shopItemSlots, 1, 6);
      const filtered = shopStock.filter((i) => settings.enabledItems[i.id]);
      const pool = [...filtered];
      const pickWeighted = (arr) => {
        const weights = arr.map((itm) => rarityWeight(itemRarity(itm)));
        const total = weights.reduce((a, b) => a + b, 0);
        if (total <= 0) return null;
        let r = Math.random() * total;
        for (let i = 0; i < arr.length; i += 1) {
          r -= weights[i];
          if (r <= 0) return i;
        }
        return arr.length - 1;
      };
      const out = [];
      while (out.length < slots && pool.length) {
        const idx = pickWeighted(pool);
        if (idx === null || idx === undefined) break;
        out.push(pool[idx]);
        pool.splice(idx, 1);
      }
      return out;
    }

    function sampleDiceOffers() {
      // Generate fresh combo dice for the shop: a base tier + ingredient pack + effect pack
      const offers = [];
      while (offers.length < 3) {
        offers.push(makeGeneratedDie());
      }
      return offers;
    }

    function priceFace(face) {
      if (face.kind === 'gold') return Math.max(2, face.gold + 1);
      if (face.kind === 'ingredient') {
        const count = Math.max(1, face.count || 1);
        return Math.max(3, 3 * count);
      }
      if (face.kind === 'effect') {
        if (face.effect === 'scorePoints') return 9;
        if (face.effect === 'doubleGoldAll') return 8;
        if (face.effect === 'doubleHighestGold') return 6;
        if (face.effect === 'doubleIngredient') return 6;
        if (face.effect === 'goldAura') return 7;
        return 5;
      }
      return 2;
    }

    const DIE_SHOP_MARKUP = 1.3;
    function dieShopCost(def) {
      return Math.ceil((def && def.price ? def.price : 0) * DIE_SHOP_MARKUP);
    }

    function facePoolFromSettings() {
      ensureToggleDefaults();
      const enabled = settings.enabledFaces;
      const pool = [];
      if (enabled.gold2) pool.push({ kind: 'gold', gold: 2, label: 'Coins +2', tag: 'gold' });
      if (enabled.gold3) pool.push({ kind: 'gold', gold: 3, label: 'Coins +3', tag: 'gold' });
      if (enabled.gold4) pool.push({ kind: 'gold', gold: 4, label: 'Coins +4', tag: 'gold' });
      if (enabled.gold5) pool.push({ kind: 'gold', gold: 5, label: 'Coins +5', tag: 'gold' });
      ingredients.forEach((ing) => {
        if (enabled[`ing_${ing}`]) pool.push(faceForIngredient(ing));
      });
      if (enabled.ing2_mana) pool.push(faceForIngredient({ ingredient: 'mana', count: 2 }));
      if (enabled.ing2_flame) pool.push(faceForIngredient({ ingredient: 'flame', count: 2 }));
      if (enabled.ing2_toxin) pool.push(faceForIngredient({ ingredient: 'toxin', count: 2 }));
      if (enabled.eff_doubleGoldAll) pool.push(cloneFace(dieEffectPacks.find((p) => p.id === 'jackpot').face));
      if (enabled.eff_doubleHighestGold) pool.push(cloneFace(dieEffectPacks.find((p) => p.id === 'fortune').face));
      if (enabled.eff_copyIngredient) pool.push(cloneFace(dieEffectPacks.find((p) => p.id === 'copycat').face));
      if (enabled.eff_wildIngredient) pool.push(cloneFace(dieEffectPacks.find((p) => p.id === 'wild').face));
      if (enabled.eff_boostGold) pool.push(cloneFace(dieEffectPacks.find((p) => p.id === 'greedy').face));
      if (enabled.eff_goldAura) pool.push(cloneFace(dieEffectPacks.find((p) => p.id === 'minted').face));
      if (enabled.eff_purgeFace) pool.push({ kind: 'effect', effect: 'purgeFace', label: 'Purge a rolled face', tag: 'effect' });
      if (enabled.eff_score15) pool.push({ kind: 'effect', effect: 'scorePoints', amount: 15, label: 'Points +15', tag: 'effect' });
      ingredients.forEach((ing) => {
        if (enabled[`eff_doubleIng_${ing}`]) {
          pool.push({ kind: 'effect', effect: 'doubleIngredient', ing, label: `Double ${ing} this roll`, tag: 'effect' });
        }
      });
      if (enabled.blank) pool.push({ kind: 'blank', label: 'Void face', tag: 'blank' });
      return pool.length ? pool : [{ kind: 'blank', label: 'Void face', tag: 'blank' }];
    }

    function makeFaceOffer() {
      const pool = facePoolFromSettings();
      const face = cloneFace(pick(pool));
      return {
        id: `face-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`,
        face,
        cost: priceFace(face)
      };
    }

    function sampleFaceOffers() {
      const offers = [];
      while (offers.length < 4) {
        offers.push(makeFaceOffer());
      }
      return offers;
    }

    function chooseDieIndexForReplacement(newDieName) {
      if (!state.dice.length) return null;
      const options = state.dice.map((die, idx) => {
        const type = getDieDef(die.typeId);
        return `${idx + 1}: ${type ? type.name : 'Unknown Die'}`;
      }).join('\n');
      const input = prompt(
        `You are at your die cap. Replace one to buy ${newDieName}.\nEnter the number to discard or Cancel to abort:\n${options}`
      );
      if (!input) return null;
      const choice = parseInt(input, 10);
      if (Number.isNaN(choice) || choice < 1 || choice > state.dice.length) {
        alert('Invalid selection.');
        return null;
      }
      return choice - 1;
    }

    function refreshShopOffers() {
      state.shopOffers = sampleShopOffers();
      state.diceShopOffers = sampleDiceOffers();
      state.faceShopOffers = sampleFaceOffers();
    }

    function closeStatsModal() {
      els.statsModal.classList.add('hidden');
    }

    function renderInventory() {
      els.diceInventoryList.innerHTML = '';
      els.invGold.textContent = state.gold;
      if (els.invDiceLabel) {
        els.invDiceLabel.textContent = `${state.dice.length} / ${state.maxDice}`;
      }
      if (!state.dice.length) {
        els.diceInventoryList.innerHTML = '<div class="empty">No dice owned.</div>';
        return;
      }

      if (state.pendingDiePurchase) {
        const notice = document.createElement('div');
        notice.className = 'list-item';
        const text = document.createElement('div');
        text.innerHTML = `<strong>Choose a die to replace</strong><div class="meta">Click any die below to swap for ${state.pendingDiePurchase.name}.</div>`;
        const cancel = document.createElement('button');
        cancel.textContent = 'Cancel';
        cancel.onclick = () => { state.pendingDiePurchase = null; log('Die replacement cancelled.'); render(); };
        notice.appendChild(text);
        notice.appendChild(cancel);
        els.diceInventoryList.appendChild(notice);
      }

      if (state.pendingDieEmpower) {
        const notice = document.createElement('div');
        notice.className = 'list-item';
        const text = document.createElement('div');
        text.innerHTML = `<strong>Empower a die</strong><div class="meta">Click a die below: coins x${state.pendingDieEmpower.goldMult || 1}, ingredients x${state.pendingDieEmpower.ingMult || 1} (permanent).</div>`;
        const cancel = document.createElement('button');
        cancel.textContent = 'Cancel';
        cancel.onclick = () => {
          state.pendingDieEmpower = null;
          log('Empower cancelled.');
          render();
        };
        notice.appendChild(text);
        notice.appendChild(cancel);
        els.diceInventoryList.appendChild(notice);
      }

      if (state.pendingDieSacrifice) {
        const notice = document.createElement('div');
        notice.className = 'list-item';
        const text = document.createElement('div');
        text.innerHTML = '<strong>Sacrifice a die</strong><div class="meta">Click a die below to destroy it. Next roll: coins/ingredients doubled; lose 1 max die.</div>';
        const cancel = document.createElement('button');
        cancel.textContent = 'Cancel';
        cancel.onclick = () => {
          state.pendingDieSacrifice = null;
          log('Sacrifice cancelled.');
          render();
        };
        notice.appendChild(text);
        notice.appendChild(cancel);
        els.diceInventoryList.appendChild(notice);
      }

      if (state.pendingFacePurchase) {
        const pending = state.pendingFacePurchase;
        const notice = document.createElement('div');
        notice.className = 'list-item';
        const text = document.createElement('div');
        text.innerHTML = `<strong>Choose a face to replace</strong><div class="meta">Click any face below to swap in ${pending.face.label}.</div>`;
        const cancel = document.createElement('button');
        cancel.textContent = 'Cancel';
        cancel.onclick = () => {
          state.gold += pending.cost;
          state.pendingFacePurchase = null;
          log('Face swap cancelled and refunded.');
          render();
        };
        notice.appendChild(text);
        notice.appendChild(cancel);
        els.diceInventoryList.appendChild(notice);
      }

      if (state.tokens.removeFace > 0) {
        const notice = document.createElement('div');
        notice.className = 'list-item';
        const text = document.createElement('div');
        text.innerHTML = `<strong>Face removal tokens</strong><div class="meta">${state.tokens.removeFace} left  removes a face from a die (cannot remove the last face)</div>`;
        const activate = document.createElement('button');
        activate.textContent = state.pendingFaceRemoval ? 'Cancel remove' : 'Use token';
        activate.onclick = () => {
          if (state.pendingFaceRemoval) {
            state.pendingFaceRemoval = false;
            log('Face removal cancelled.');
            render();
            return;
          }
          state.pendingFaceRemoval = true;
          log('Face removal ready: click a die face to remove it.');
          render();
        };
        notice.appendChild(text);
        notice.appendChild(activate);
        els.diceInventoryList.appendChild(notice);
      }

      state.dice.forEach((die, index) => {
        const type = getDieDef(die.typeId);
        const faces = getDieFaces(die);
        const rarity = dieRarity(type, faces);
        const row = document.createElement('div');
        row.className = `list-item ${rarityClass(rarity)}`.trim();
        if (state.pendingDiePurchase) {
          row.style.cursor = 'pointer';
          row.classList.add('select-glow');
          row.title = 'Click to replace with new die';
          row.onclick = () => replaceDieAtIndex(index);
        } else if (state.pendingDieEmpower) {
          row.style.cursor = 'pointer';
          row.classList.add('select-glow');
          row.title = 'Click to empower this die';
          row.onclick = () => empowerDieAtIndex(index);
        } else if (state.pendingDieSacrifice) {
          row.style.cursor = 'pointer';
          row.classList.add('select-glow-danger');
          row.title = 'Click to sacrifice this die';
          row.onclick = () => sacrificeDieAtIndex(index);
        }
        if (state.pendingFacePurchase || state.pendingFaceRemoval || state.pendingFaceUpgrade) {
          row.classList.add('select-glow');
        }
        const left = document.createElement('div');
        left.innerHTML = `<strong>${type ? type.name : 'Unknown Die'}</strong><div class="meta">Owned die #${index + 1}</div>`;
        const facesWrap = document.createElement('div');
        facesWrap.className = 'pill-row';
        faces.forEach((f, faceIdx) => {
          const chip = document.createElement('span');
          chip.className = `face-chip ${faceRarityClass(f)}`.trim();
          chip.innerHTML = `<span class="mini-tag">${f.tag}</span>${f.label}`;
          if (state.pendingFacePurchase) {
            chip.style.cursor = 'pointer';
            chip.classList.add('select-glow');
            chip.title = `Replace with ${state.pendingFacePurchase.face.label}`;
            chip.onclick = (e) => { e.stopPropagation(); replaceFaceOnDie(index, faceIdx); };
          } else if (state.pendingFaceRemoval) {
            chip.style.cursor = 'pointer';
            chip.classList.add('select-glow-danger');
            chip.title = 'Remove this face (uses a token)';
            chip.onclick = (e) => { e.stopPropagation(); removeFaceFromDie(index, faceIdx); };
          } else if (state.pendingFaceUpgrade) {
            chip.style.cursor = 'pointer';
            chip.classList.add('select-glow');
            chip.title = state.pendingFaceUpgrade.type === 'gold'
              ? `Upgrade this gold face by +${state.pendingFaceUpgrade.delta}`
              : 'Turn this ingredient face into a double';
            chip.onclick = (e) => { e.stopPropagation(); applyPendingFaceUpgrade(index, faceIdx); };
          }
          facesWrap.appendChild(chip);
        });
        row.appendChild(left);
        row.appendChild(facesWrap);
        els.diceInventoryList.appendChild(row);
      });
    }

    function renderInventoryPotions() {
      els.potionInventoryList.innerHTML = '';
      if (!state.potions.length) {
        els.potionInventoryList.innerHTML = '<div class="empty">No potions in inventory.</div>';
        if (els.sellAllShop) els.sellAllShop.disabled = true;
        return;
      }
      if (els.sellAllShop) els.sellAllShop.disabled = false;
      state.potions.forEach((p, idx) => {
        const item = document.createElement('div');
        const rarity = potionRarity(p);
        item.className = `list-item ${rarityClass(rarity)}`.trim();
        const info = document.createElement('div');
        info.innerHTML = `<strong>${p.name}</strong><div class="meta">Sell ${p.sell}  Consume: ${p.consume.text}</div>`;
        const actions = document.createElement('div');
        actions.className = 'cta-row';
        const sell = document.createElement('button');
        sell.textContent = `Sell (+${p.sell})`;
        sell.onclick = () => {
          const bonus = potionSellBonusForRound();
          const total = p.sell + bonus;
          gainGold(total);
          log(`Sold ${p.name} for ${total} Gold${bonus ? ` (base ${p.sell} +${bonus})` : ''}.`);
          state.potions.splice(idx, 1);
          render();
        };
        const consume = document.createElement('button');
        consume.textContent = 'Consume';
        consume.onclick = () => {
          applyPotion(p.consume);
          recordPotionConsume();
          state.potions.splice(idx, 1);
          log(`Consumed ${p.name}.`);
          render();
        };
        actions.appendChild(sell);
        actions.appendChild(consume);
        item.appendChild(info);
        item.appendChild(actions);
        els.potionInventoryList.appendChild(item);
      });
    }

    function renderInventoryItems() {
      const renderItemsList = (container, inShop) => {
        if (!container) return;
        container.innerHTML = '';
        const hasItems = state.items.length > 0 || state.tokens.reroll > 0;
        if (!hasItems) {
          container.innerHTML = '<div class="empty">No items yet.</div>';
          return;
        }
        if (state.tokens.reroll > 0) {
          const row = document.createElement('div');
          row.className = 'list-item';
          row.innerHTML = `<div><strong>Shop Reroll Tokens</strong><div class="meta">Count: ${state.tokens.reroll} (refreshes shop offers)</div></div>`;
          container.appendChild(row);
        }
        state.items.forEach((itm, idx) => {
          const row = document.createElement('div');
          const rarity = itm.rarity || itemRarity(itm);
          row.className = `list-item ${rarityClass(rarity)}`.trim();
          row.innerHTML = `<div><strong>${itm.name}</strong><div class="meta">${itm.desc}</div></div>`;
          const btn = document.createElement('button');
          const rollOnly = inShop && itm.shopUsable === false;
          const preRollLocked = (!inShop || state.stage === 'roll') && itm.preRollOnly && state.rolled;
          btn.textContent = rollOnly ? 'Use (roll only)' : 'Use';
          btn.disabled = rollOnly || preRollLocked;
          if (rollOnly) {
            btn.title = 'Use this during the roll/cauldron phase so it is not wasted.';
          } else if (preRollLocked) {
            btn.title = 'Use before rolling (all items must be used pre-roll).';
          } else {
            btn.onclick = () => {
              const result = itm.action(state);
              log(result);
              state.items.splice(idx, 1);
              render();
            };
          }
          row.appendChild(btn);
          container.appendChild(row);
        });
      };

      renderItemsList(els.itemInventoryList, true);
      renderItemsList(els.itemInventoryRoll, false);
    }

    function applyPotion(effect) {
      switch (effect.type) {
        case 'heal': {
          if (effect.dice) {
            state.statuses.push({ type: 'bonusDice', amount: effect.dice, expires: effectTargetRound() });
          }
          if (effect.shields) {
            state.statuses.push({ type: 'shield', amount: effect.shields, expires: effectTargetRound() });
          }
          break;
        }
        case 'score': {
          const amt = effect.amount !== undefined ? effect.amount : 0;
          state.stats.score += amt;
          log(`Gained ${amt} point${amt === 1 ? '' : 's'}.`);
          render();
          break;
        }
        case 'gold':
          gainGold(effect.gold);
          break;
        case 'reroll':
          addRerollTokens(effect.rerolls);
          break;
        case 'removeFaceToken':
          if (effect.tokens) {
            state.tokens.removeFace = Math.max(0, state.tokens.removeFace) + effect.tokens;
            log(`Gained ${effect.tokens} face-removal token${effect.tokens > 1 ? 's' : ''}.`);
            render();
          }
          break;
        case 'shield': {
          if (effect.shields) {
            state.statuses.push({ type: 'shield', amount: effect.shields, expires: effectTargetRound() });
          }
          if (effect.gold) {
            gainGold(effect.gold);
          }
          break;
        }
        case 'ingToGold': {
          const per = effect.goldPerIng !== undefined ? effect.goldPerIng : 6;
          state.statuses.push({ type: 'ingToGold', amount: per, expires: effectTargetRound() });
          log(`Next roll: each ingredient converts to ${per} Gold.`);
          break;
        }
        case 'tieredCoinToIng': {
          state.statuses.push({ type: 'tieredCoinToIng', expires: effectTargetRound() });
          log('Next roll: each gold face gives 1 ingredient based on its value.');
          break;
        }
        case 'dieReroll': {
          const amt = effect.amount !== undefined ? effect.amount : 1;
          state.statuses.push({ type: 'dieRerollToken', amount: amt, expires: effectTargetRound() });
          log(`Stored ${amt} die reroll${amt === 1 ? '' : 's'} for the target round. Roll, then click a die to reroll${amt === 1 ? '' : ' up to ' + amt + ' times'}.`);
          break;
        }
        case 'duplicateDiceLoseRound': {
          const clones = state.dice.map((d) => cloneDie(d)).filter(Boolean);
          state.statuses.push({ type: 'duplicateDice', clones, expires: effectTargetRound() });
          const newMax = Math.max(state.round, state.maxRounds - 1);
          const lost = state.maxRounds - newMax;
          state.maxRounds = newMax;
          log(`Next roll will include duplicates of all dice. Lost ${lost} round${lost === 1 ? '' : 's'} (max now ${state.maxRounds}).`);
          break;
        }
        case 'potionSellBonus': {
          const amount = effect.amount !== undefined ? effect.amount : 0;
          state.statuses.push({ type: 'potionSellBonus', amount, expires: effectTargetRound() });
          log(`Next round: potions sell for +${amount} Gold.`);
          break;
        }
        case 'unusedIngGold': {
          const amount = effect.amount !== undefined ? effect.amount : 30;
          const ings = Array.isArray(effect.ings) && effect.ings.length ? effect.ings : ingredients;
          state.statuses.push({ type: 'unusedIngGold', amount, ings: [...ings], expires: effectTargetRound() });
          log(`Next round: gain ${amount} Gold per unused ${ings.join('/')} left in inventory.`);
          break;
        }
        case 'ingredientMultiplier': {
          const mult = effect.multiplier && effect.multiplier > 0 ? effect.multiplier : 1;
          state.statuses.push({ type: 'ingredientMultiplier', ing: effect.ing, multiplier: mult });
          log(`Permanent: ${effect.ing || 'Ingredients'} count x${mult}.`);
          break;
        }
        case 'extendMaxRounds': {
          const amt = effect.amount !== undefined ? effect.amount : 1;
          const before = state.maxRounds;
          state.maxRounds = Math.min(99, state.maxRounds + amt);
          const gained = state.maxRounds - before;
          log(gained > 0
            ? `Run extended by ${gained} round${gained === 1 ? '' : 's'} (max rounds now ${state.maxRounds}).`
            : 'Run length unchanged (already at cap).');
          break;
        }
        case 'sacrificeDoubleRoll': {
          const expires = effectTargetRound();
          state.pendingDieSacrifice = { expires };
          log('Select a die to sacrifice. Next roll: coins and ingredients doubled; max dice -1.');
          render();
          break;
        }
        case 'convertIngredients': {
          const from = effect.from || 'toxin';
          const to = effect.to || 'essence';
          const mult = effect.multiplier && effect.multiplier > 0 ? effect.multiplier : 1;
          state.statuses.push({ type: 'convertIngredient', from, to, multiplier: mult, expires: effectTargetRound() });
          log(`Next roll: each ${from} becomes ${mult} ${to}.`);
          break;
        }
        case 'addDieSlot': {
          const before = state.maxDice;
          state.maxDice += 1;
          const gained = state.maxDice - before;
          log(gained > 0 ? `Max dice increased by ${gained} (now ${state.maxDice}).` : 'Max dice already at cap.');
          render();
          break;
        }
        case 'randomShopItems': {
          ensureToggleDefaults();
          const pool = shopStock.filter((i) => settings.enabledItems ? settings.enabledItems[i.id] !== false : true);
          if (!pool.length) {
            log('No shop items available to grant.');
            break;
          }
          const count = effect.count && effect.count > 0 ? Math.floor(effect.count) : 2;
          const picks = shuffle(pool).slice(0, count);
          const messages = [];
          const names = [];
          picks.forEach((itm) => {
            const msg = grantShopItem(itm);
            if (msg) messages.push(msg);
            names.push(itm.name);
          });
          if (names.length) {
            log(`Smokestack Veil granted: ${names.join(', ')}.`);
          }
          messages.forEach((m) => log(m));
          break;
        }
        case 'passiveGoldPerRound': {
          const amount = effect.amount !== undefined ? effect.amount : 4;
          state.statuses.push({ type: 'passiveRoundGold', amount });
          log(`Passive unlocked: +${amount} Gold at the start of each remaining round.`);
          break;
        }
        case 'delayedIngredients': {
          if (effect.ingredients && effect.ingredients.length) {
            state.statuses.push({ type: 'delayedIngredients', ings: [...effect.ingredients], expires: effectTargetRound() });
            log(`Will gain ${effect.ingredients.join(' + ')} on the next roll.`);
          }
          break;
        }
        case 'cloneDie': {
          if (!state.dice.length) { log('No dice to copy.'); break; }
          const source = pick(state.dice);
          const def = getDieDef(source.typeId);
          const cloned = cloneDie(source);
          if (!cloned) { log('Failed to copy die.'); break; }
          state.statuses.push({ type: 'bonusCloneDie', die: cloned, name: def ? def.name : 'a die', expires: effectTargetRound() });
          log(`A bonus copy of ${def ? def.name : 'a die'} will roll next.`);
          break;
        }
        case 'boost':
          // perDie applies to next roll; also allow flat gold bump if present
          if (effect.perDie !== undefined) {
            state.statuses.push({ type: 'perDieGold', amount: effect.perDie, expires: effectTargetRound() });
          }
          if (effect.gold) {
            gainGold(effect.gold);
          }
          break;
        case 'bankGoldNext': {
          const cap = effect.cap !== undefined ? effect.cap : 15;
          const mult = effect.multiplier !== undefined ? effect.multiplier : 2;
          const available = Math.max(0, Math.min(cap, state.gold));
          if (!available) {
            log('No Gold to bank for next round.');
            break;
          }
          state.gold -= available;
          const payout = available * mult;
          state.statuses.push({ type: 'bankedGoldNext', amount: payout, expires: state.round + 1 });
          log(`Banked ${available} Gold; will gain ${payout} Gold at the start of next round.`);
          render();
          break;
        }
        case 'empowerDie': {
          const goldMult = effect.goldMult && effect.goldMult > 0 ? effect.goldMult : 1;
          const ingMult = effect.ingMult && effect.ingMult > 0 ? effect.ingMult : 1;
          state.pendingDieEmpower = { goldMult, ingMult };
          log(`Select a die to empower: coins x${goldMult}, ingredients x${ingMult} (permanent).`);
          render();
          break;
        }
        case 'coinFlipJackpot': {
          const win = Math.random() < 0.5;
          if (win) {
            const amt = effect.gold !== undefined ? effect.gold : 100;
            gainGold(amt);
            log(`Lucky coin flip: +${amt} Gold.`);
          } else {
            log('The toxin backfires: your run ends immediately.');
            endGame();
          }
          break;
        }
        default:
          break;
      }
    }

    function renderShop() {
      els.shopList.innerHTML = '';
      if (els.rerollShop) {
        const left = state.shopRerollsLeft !== undefined ? state.shopRerollsLeft : 0;
        els.rerollShop.textContent = `Reroll Shop (-3 Gold or 1 token)  ${left} left`;
      }
      const offers = Array.isArray(state.shopOffers) ? state.shopOffers : shopStock;
      offers.forEach((item) => {
        const row = document.createElement('div');
        const rarity = itemRarity(item);
        row.className = `list-item ${rarityClass(rarity)}`.trim();
        const label = item.permanent ? 'Permanent' : (item.consumable ? 'Consumable' : 'Immediate');
        row.innerHTML = `<div><strong>${item.name}</strong><div class="meta">Cost: ${item.cost}  ${item.desc} <span class="tag effect" style="margin-left:6px;">${label}</span></div></div>`;
        const btn = document.createElement('button');
        btn.textContent = 'Buy';
        btn.onclick = () => {
          if (state.gold < item.cost) { log('Not enough gold.'); return; }
          state.gold -= item.cost;
          const removeOffer = () => {
            if (state.shopOffers) {
              state.shopOffers = state.shopOffers.filter((o) => o.id !== item.id);
            }
          };
          if (item.consumable) {
            if (item.autoUseOnPurchase) {
              const result = item.action(state);
              recordItemBought();
              log(result);
              removeOffer();
              render();
              return;
            }
            state.items.push({
              id: `${item.id}-${Date.now()}`,
              name: item.name,
              desc: item.desc,
              action: item.action,
              shopUsable: item.shopUsable !== false,
              preRollOnly: true,
              rarity
            });
            recordItemBought();
            log(`Added ${item.name} to inventory.`);
            removeOffer();
            render();
            return;
          }
          const result = item.action(state);
          recordItemBought();
          log(result);
          removeOffer();
          render();
        };
        row.appendChild(btn);
        els.shopList.appendChild(row);
      });
      const slots = clamp(settings.shopItemSlots, 1, 6);
      const placeholderCount = Math.max(0, slots - offers.length);
      for (let i = 0; i < placeholderCount; i += 1) {
        const row = document.createElement('div');
        row.className = 'list-item';
        row.innerHTML = '<div><strong>Empty slot</strong><div class="meta">Reroll the shop to refresh offers.</div></div>';
        els.shopList.appendChild(row);
      }
    }

    function nextExtraSlotCost() {
      return extraSlotCosts[state.extraSlotsBought] ?? null;
    }

    function renderExtraSlotPurchase() {
      if (!els.extraSlotLabel || !els.buyExtraSlotBtn) return;
      const bought = state.extraSlotsBought || 0;
      const cost = nextExtraSlotCost();
      if (cost === null) {
        els.extraSlotLabel.textContent = `Extra die slots: ${bought}/3 purchased (all available slots bought).`;
        els.buyExtraSlotBtn.disabled = true;
        els.buyExtraSlotBtn.textContent = 'All slots bought';
        return;
      }
      const remaining = extraSlotCosts.length - bought;
      els.extraSlotLabel.textContent = `Extra die slots: ${bought}/3  Next costs ${cost} Gold (remaining ${remaining}).`;
      els.buyExtraSlotBtn.textContent = `Buy +1 slot (${cost} Gold)`;
      els.buyExtraSlotBtn.disabled = state.gold < cost;
    }

    function renderDiceShop() {
      renderExtraSlotPurchase();
      els.diceShopList.innerHTML = '';
      const offers = state.diceShopOffers && state.diceShopOffers.length
        ? state.diceShopOffers
        : sampleDiceOffers();
      offers.forEach((dieType, idx) => {
        if (!dieType) {
          const emptyRow = document.createElement('div');
          emptyRow.className = 'list-item';
          emptyRow.innerHTML = '<div><strong>Empty slot</strong><div class="meta">Reroll the shop to refresh dice offers.</div></div>';
          els.diceShopList.appendChild(emptyRow);
          return;
        }
        const rarity = dieRarity(dieType, dieType.faces);
        const cost = dieShopCost(dieType);
        const row = document.createElement('div');
        row.className = `list-item ${rarityClass(rarity)}`.trim();
        const facesWrap = document.createElement('div');
        facesWrap.className = 'pill-row';
        dieType.faces.forEach((f) => {
          const chip = document.createElement('span');
          chip.className = `face-chip ${faceRarityClass(f, dieType.price)}`.trim();
          chip.innerHTML = `<span class="mini-tag">${f.tag}</span>${f.label}`;
          facesWrap.appendChild(chip);
        });
        const info = document.createElement('div');
        info.innerHTML = `<strong>${dieType.name}</strong><div class="meta">Cost: ${cost}</div>`;
        const btn = document.createElement('button');
        btn.textContent = 'Buy Die';
        btn.onclick = () => {
          if (state.gold < cost) { log('Not enough gold.'); return; }
          if (state.dice.length >= state.maxDice) {
            state.pendingDiePurchase = { typeId: dieType.id, name: dieType.name, cost, offerIndex: idx };
            log(`Select a die to replace with ${dieType.name}. Click a die below.`);
            render();
            return;
          }
          state.gold -= cost;
          state.dice.push(makeDie(dieType.id));
          recordItemBought();
          log(`Bought ${dieType.name}.`);
          if (state.diceShopOffers) {
            state.diceShopOffers[idx] = null;
          }
          render();
        };
        row.appendChild(info);
        row.appendChild(facesWrap);
        row.appendChild(btn);
        els.diceShopList.appendChild(row);
      });
    }

    function buyExtraSlot() {
      const cost = nextExtraSlotCost();
      if (cost === null) {
        log('All extra die slots have been purchased.');
        return;
      }
      if (state.gold < cost) {
        log(`Need ${cost} Gold to buy the next die slot.`);
        return;
      }
      state.gold -= cost;
      state.extraSlotsBought = (state.extraSlotsBought || 0) + 1;
      state.maxDice += 1;
      const remaining = Math.max(0, extraSlotCosts.length - state.extraSlotsBought);
      log(`Bought an extra die slot. Max dice is now ${state.maxDice}. ${remaining} slot${remaining === 1 ? '' : 's'} remain.`);
      render();
    }

    function renderFaceShop() {
      els.faceShopList.innerHTML = '';
      const offers = state.faceShopOffers && state.faceShopOffers.length
        ? state.faceShopOffers
        : sampleFaceOffers();
      offers.forEach((offer, idx) => {
        const row = document.createElement('div');
        const rarity = offer ? faceRarity(offer.face, offer.cost) : 'common';
        row.className = `list-item ${rarityClass(rarity)}`.trim();
        if (!offer) {
          row.innerHTML = '<div><strong>Empty slot</strong><div class="meta">Reroll the shop to refresh face offers.</div></div>';
          els.faceShopList.appendChild(row);
          return;
        }
        const faceChip = document.createElement('span');
        faceChip.className = `face-chip ${faceRarityClass(offer.face, offer.cost)}`.trim();
        faceChip.innerHTML = `<span class="mini-tag">${offer.face.tag}</span>${offer.face.label}`;
        const info = document.createElement('div');
        info.innerHTML = `<strong>${offer.face.label}</strong><div class="meta">Cost: ${offer.cost}</div>`;
        const btn = document.createElement('button');
        btn.textContent = 'Buy Face';
        btn.onclick = () => {
          if (state.pendingFacePurchase) { log('Finish your current face swap first.'); return; }
          if (state.gold < offer.cost) { log('Not enough gold.'); return; }
          state.gold -= offer.cost;
          state.pendingFacePurchase = { face: cloneFace(offer.face), cost: offer.cost, offerIndex: idx };
          recordItemBought();
          log(`Bought a die face: ${offer.face.label}. Click a die face to replace it.`);
          if (state.faceShopOffers) {
            state.faceShopOffers[idx] = null;
          }
          render();
        };
        row.appendChild(info);
        row.appendChild(faceChip);
        row.appendChild(btn);
        els.faceShopList.appendChild(row);
      });
    }

    function renderStatuses() {
      els.statusRow.innerHTML = '';
      const active = state.statuses;
      if (!active.length && state.tokens.reroll === 0 && !state.pendingDieReroll && !state.pendingFacePurchase && !state.pendingFaceRemoval && !state.pendingFaceUpgrade && !state.pendingDieSacrifice && !state.pendingDieEmpower && (state.tokens.removeFace || 0) === 0) {
        els.statusRow.innerHTML = '<div class="empty">No active effects.</div>';
        return;
      }
      const labels = {
        bonusDice: (s) => `+${s.amount} bonus die next roll`,
        perDieGold: (s) => `+${s.amount} Gold per die`,
        shield: () => 'Toxin shield',
        goldDoubler: () => 'Gold gains doubled',
        goldFaceBonus: (s) => `+${s.amount} Gold on each gold face`,
        uniqueGoldBonus: (s) => `+${s.amount} Gold per unique ingredient`,
        doubleIng: (s) => {
          const extra = s.gained ? ` (+${s.gained})` : '';
          return `Double ${s.ing} gains${extra}`;
        },
        bonusCloneDie: (s) => `Bonus copy: ${s.name || 'die'}`,
        delayedIngredients: (s) => `Delayed: ${Array.isArray(s.ings) ? s.ings.join(' + ') : 'ingredients'}`,
        passiveRoundGold: (s) => `Permanent: +${s.amount || 0} Gold each round`,
        convertIngredient: (s) => `Convert ${s.from || '?'}  ${s.multiplier || 1}${s.to || '?'}`,
        ingToGold: (s) => `Ingredients  ${s.amount || 0} Gold`,
        goldToIngredient: () => 'Coins  random ingredients',
        tieredCoinToIng: () => 'Gold face  1 ingredient based on value',
        doubleCoinIng: () => 'Coins/ingredients x2',
        unusedIngGold: (s) => {
          const names = Array.isArray(s.ings) && s.ings.length ? s.ings.join('/') : 'ingredients';
          return `Unused ${names}  +${s.amount || 0} Gold`;
        },
        firstIngDoubler: (s) => `Permanent: first ${s.ing || 'ingredient'} doubled each round`,
        dieMod: (s) => `Die buff: coins x${s.goldMult || 1}, ingredients x${s.ingMult || 1}`,
        goldMultiplier: (s) => `Gold faces x${s.amount || 1} (R${s.expires || state.round})`,
        ingredientMultiplier: (s) => `Permanent: ${s.ing || 'Ingredients'} x${s.multiplier || 1}`,
        duplicateDice: () => 'Next roll: duplicate all dice',
        potionSellBonus: (s) => `Potions sell +${s.amount || 0} (R${s.expires || state.round})`,
        potionSellPassive: (s) => `Potions sell +${s.amount || 0}`,
        ingredientPoints: (s) => `+${s.amount || 0} pts per ingredient`,
        dieRerollToken: (s) => `Die rerolls stored: ${s.amount || 1}`,
        passiveDieReroll: (s) => `Permanent: +${s.amount || 1} die reroll each round`,
        shopRerollMaxBonus: (s) => `Permanent: +${s.amount || 1} max shop reroll each round`,
        excessGoldDouble: (s) => `Permanent: Gold over ${s.threshold || 5} doubled`,
        cheapShopReroll: (s) => `Permanent: Shop rerolls cost ${s.cost !== undefined ? s.cost : 3}`,
        passiveGoldOnGold: (s) => `Permanent: +${s.amount} Gold on gold faces`,
        passiveManaFloor: () => 'Permanent: Gain 1 Mana if none rolled',
        passiveGoldFloor: (s) => `Permanent: Raise low gold to ${s.floor || 5}`,
        character: (s) => `Character: ${s.name || 'Unknown'}`,
        pendingReroll: () => 'Select a die to reroll'
      };
      if (state.pendingFaceUpgrade) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = state.pendingFaceUpgrade.type === 'gold'
          ? `Face upgrade ready: +${state.pendingFaceUpgrade.delta} Gold (click a gold face)`
          : 'Face upgrade ready: make ingredient x2 (click a face)';
        els.statusRow.appendChild(span);
      }
      if (state.effectNotes && state.effectNotes.length) {
        state.effectNotes.forEach((note) => {
          const span = document.createElement('span');
          span.className = 'tag gold';
          span.textContent = `Applied: ${note}`;
          els.statusRow.appendChild(span);
        });
      }

      active.forEach((s) => {
        const span = document.createElement('span');
        span.className = 'tag effect';
        const labelFn = labels[s.type];
        const roundTag = s.expires ? `  R${s.expires}` : '  Permanent';
        span.textContent = labelFn ? `${labelFn(s)}${roundTag}` : `${s.type} (${s.amount || ''})${roundTag}`;
        els.statusRow.appendChild(span);
      });
      if (state.pendingDieReroll) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = `Click a die to reroll (${state.dieRerollsLeft || 0} left)`;
        els.statusRow.appendChild(span);
        const cancel = document.createElement('span');
        cancel.className = 'tag danger';
        cancel.style.cursor = 'pointer';
        cancel.textContent = 'Cancel reroll';
        cancel.onclick = cancelPendingDieReroll;
        els.statusRow.appendChild(cancel);
      }
      if (state.pendingDieSacrifice) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = 'Select a die to sacrifice';
        els.statusRow.appendChild(span);
      }
      if (state.pendingDieEmpower) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = 'Select a die to empower';
        els.statusRow.appendChild(span);
      }
      if (state.pendingFacePurchase) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = `Face ready: ${state.pendingFacePurchase.face.label}`;
        els.statusRow.appendChild(span);
      }
      if (state.tokens.reroll > 0) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = `Shop reroll tokens: ${state.tokens.reroll}`;
        els.statusRow.appendChild(span);
      }
      if ((state.tokens.removeFace || 0) > 0) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = `Face removal tokens: ${state.tokens.removeFace}`;
        els.statusRow.appendChild(span);
      }
      if (state.pendingFaceRemoval) {
        const span = document.createElement('span');
        span.className = 'tag effect';
        span.textContent = 'Face removal active: click a die face to remove it';
        els.statusRow.appendChild(span);
      }
    }

    function renderHeader() {
      els.roundLabel.textContent = `${state.round} / ${state.maxRounds}`;
      els.goldLabel.textContent = state.gold;
      if (els.invRound) els.invRound.textContent = `${state.round} / ${state.maxRounds}`;
      if (els.backToBrew) {
        els.backToBrew.textContent = state.round >= state.maxRounds ? 'End Game' : 'Start Next Round';
      }
      if (els.scoreLabel) els.scoreLabel.textContent = state.stats.score;
      if (els.invDiceLabel) els.invDiceLabel.textContent = `${state.dice.length} / ${state.maxDice}`;
      const progress = ((state.round - 1) / state.maxRounds) * 100;
      els.progressBar.style.width = `${progress}%`;
    }

    function recordIngredient(ing) {
      state.ingredients.push(ing);
      if (state.stats.ingredients[ing] !== undefined) state.stats.ingredients[ing] += 1;
      const ingPoints = state.statuses
        .filter((s) => s.type === 'ingredientPoints')
        .reduce((sum, s) => sum + (s.amount || 0), 0);
      if (ingPoints > 0) {
        state.stats.score += ingPoints;
      }
      const doublers = state.statuses.filter((s) => s.type === 'doubleIng' && s.ing === ing && s.expires === state.round);
      if (doublers.length) {
        state.ingredients.push(ing);
        if (state.stats.ingredients[ing] !== undefined) state.stats.ingredients[ing] += 1;
        doublers.forEach((d) => { d.gained = (d.gained || 0) + 1; });
        log(`Ingredient doubled: gained extra ${ing}.`);
      }
      const multipliers = state.statuses.filter((s) => s.type === 'ingredientMultiplier' && (!s.ing || s.ing === ing));
      if (multipliers.length) {
        const extra = multipliers.reduce((sum, m) => sum + Math.max(0, (m.multiplier || 1) - 1), 0);
        for (let i = 0; i < extra; i += 1) {
          state.ingredients.push(ing);
          if (state.stats.ingredients[ing] !== undefined) state.stats.ingredients[ing] += 1;
        }
      }
    }

    function applyRollFaces(rolls) {
      if (!state.rollSnapshot) {
        log('No roll snapshot to rerun.');
        return;
      }
      const snap = state.rollSnapshot;
      state.gold = snap.gold;
      state.ingredients = [...snap.ingredients];
      state.stats.ingredients = { ...snap.statsIngredients };
      state.stats.score = snap.score;

      const totalDice = rolls.length;
      const goldBefore = state.gold;
      const hasGoldDoubler = state.statuses.some((s) => s.type === 'goldDoubler' && s.expires === state.round);
      const goldFaceBonus = goldFaceBonusForRoll();
      const uniqueGoldBonus = state.statuses
        .filter((s) => s.type === 'uniqueGoldBonus' && s.expires === state.round)
        .reduce((sum, s) => sum + s.amount, 0);

      const hasDoubleGoldAll = rolls.some(({ face }) => face.kind === 'effect' && face.effect === 'doubleGoldAll');
      const goldAllMult = hasDoubleGoldAll ? 2 : 1;

      const effectNotes = [];

      const summary = { ingredients: [], goldFaces: [], effects: [], goldAllMult: goldAllMult, notes: effectNotes };

      let convertedCoinTotal = 0;

      const goldToIngActive = state.statuses.some((s) => s.type === 'goldToIngredient' && s.expires === state.round);
      const tieredCoinActive = state.statuses.some((s) => s.type === 'tieredCoinToIng' && s.expires === state.round);
      const doubleCoinIngActive = state.statuses.some((s) => s.type === 'doubleCoinIng' && s.expires === state.round);

      if (goldFaceBonus) effectNotes.push(`Gold faces +${goldFaceBonus} each this roll`);
      if (goldAllMult > 1) effectNotes.push(`Gold gains x${goldAllMult} this roll`);
      if (goldToIngActive) effectNotes.push('Coins convert to random ingredients this roll');
      if (tieredCoinActive) effectNotes.push('Gold faces convert to 1 ingredient based on value');
      if (doubleCoinIngActive) effectNotes.push('Coin/ingredient faces give double ingredients');

      const delayed = takeDelayedIngredientsForRound();
      if (delayed.length) {
        delayed.forEach((ing) => summary.ingredients.push(ing));
        log(`Delayed ingredients granted: ${delayed.join(' + ')}.`);
      }

      rolls.forEach((entry) => {
        const { face } = entry;
        const mods = dieModifiers(entry.die);
        const dieGoldMult = mods.reduce((prod, m) => prod * (m.goldMult || 1), 1);
        const dieIngMult = mods.reduce((prod, m) => prod * (m.ingMult || 1), 1);
        if (face.kind === 'ingredient') {
          const baseCount = Math.max(1, face.count || 1);
          const count = Math.max(1, Math.round(baseCount * (doubleCoinIngActive ? 2 : 1) * (dieIngMult || 1)));
          for (let c = 0; c < count; c += 1) summary.ingredients.push(face.ingredient);
          const firstDoubler = state.statuses.find((s) => s.type === 'firstIngDoubler' && s.ing === face.ingredient && s.usedAtRound !== state.round);
          if (firstDoubler) {
            summary.ingredients.push(face.ingredient);
            firstDoubler.usedAtRound = state.round;
            log(`First ${face.ingredient} doubled (Sigil).`);
          }
        }
        if (face.kind === 'gold') {
          const totalGold = face.gold + goldFaceBonus;
          const goldMult = state.statuses
            .filter((s) => s.type === 'goldMultiplier' && s.expires === state.round)
            .reduce((prod, s) => prod * (s.amount || 1), 1);
          const finalGold = Math.round(totalGold * (goldMult || 1) * (dieGoldMult || 1) * goldAllMult);
          const coinCount = doubleCoinIngActive ? finalGold * 2 : finalGold;
          if (tieredCoinActive) {
            const ing = coinCount >= 5 ? 'essence' : coinCount === 4 ? 'toxin' : coinCount === 3 ? 'flame' : coinCount === 2 ? 'health' : 'mana';
            summary.ingredients.push(ing);
            summary.goldFaces.push(0);
            effectNotes.push(`Converted ${coinCount} gold  ${ing}`);
          } else if (goldToIngActive) {
            for (let g = 0; g < coinCount; g += 1) {
              summary.ingredients.push(pick(ingredients));
            }
            convertedCoinTotal += coinCount;
            summary.goldFaces.push(0);
          } else {
            summary.goldFaces.push(coinCount);
            gainGold(coinCount);
          }
        }
        if (face.kind === 'effect') summary.effects.push(face.effect);
      });

      if (goldToIngActive) {
        const convertedCoins = convertedCoinTotal;
        const added = summary.ingredients.length - delayed.length - rolls.filter((r) => r.face.kind === 'ingredient').reduce((sum, r) => sum + Math.max(1, r.face.count || 1) * (doubleCoinIngActive ? 2 : 1), 0);
        if (added > 0) {
          log(`Converted ${convertedCoins} coin${convertedCoins === 1 ? '' : 's'} into random ingredients.`);
        }
      }

      const perDieBonus = state.statuses.filter((s) => s.type === 'perDieGold' && s.expires === state.round)
        .reduce((sum, s) => sum + s.amount, 0);
      if (perDieBonus) {
        const gain = perDieBonus * totalDice * goldAllMult;
        gainGold(gain);
        effectNotes.push(`Per-die bonus: +${gain} Gold (${perDieBonus}/die)`);
        log(`Boost: +${gain} Gold from per-die bonus.`);
      }

      applyEffects(rolls, summary);

      summary.ingredients = convertIngredientsForRound(summary.ingredients);
      convertIngredientsToGold(summary, summary.goldAllMult || 1);

      const addManaSafety = state.statuses.some((s) => s.type === 'passiveManaFloor');
      if (addManaSafety && !summary.ingredients.includes('mana')) {
        summary.ingredients.push('mana');
        effectNotes.push('Passive: gained 1 Mana (none rolled)');
        log('Passive: gained 1 Mana (none rolled).');
      }

      if (uniqueGoldBonus && summary.ingredients.length) {
        const uniqueCount = new Set(summary.ingredients).size;
        const gain = uniqueGoldBonus * uniqueCount * (summary.goldAllMult || 1);
        gainGold(gain);
        effectNotes.push(`Unique bonus: +${gain} Gold (${uniqueCount} unique ings)`);
        log(`Unique bonus: +${gain} Gold from ${uniqueCount} unique ingredients.`);
      }
      summary.ingredients.forEach((ing) => recordIngredient(ing));
      const floorTarget = passiveGoldFloorValue();
      if (floorTarget) {
        const gained = state.gold - goldBefore;
        if (gained < floorTarget) {
          const add = floorTarget - gained;
          gainGold(add);
          effectNotes.push(`Passive floor: raised Gold gain to ${floorTarget} (+${add})`);
          log(`Passive: raised Gold gain to ${floorTarget} (+${add}).`);
        }
      }

      if (summary.goldAllMult && summary.goldAllMult > 1) {
        effectNotes.push(`Gold multiplier active: x${summary.goldAllMult}`);
      }

      state.effectNotes = effectNotes;
      applyExcessGoldBonus(goldBefore);
      if (hasGoldDoubler) {
        const gained = state.gold - goldBefore;
        if (gained > 0) {
          gainGold(gained);
          log(`Gold Doubler: +${gained} extra Gold.`);
        }
      }

      state.currentRolls = rolls;
      renderDice(rolls);
      render();
    }

    function finalizeCurrentRoll() {
      if (state.rollResolved) return;
      if (!state.currentRolls || !state.currentRolls.length) { log('No roll to finalize.'); return; }
      if (!state.rollSnapshot) { log('No roll snapshot to resolve.'); return; }
      state.rollResolved = true;
      state.pendingDieReroll = false;
      state.dieRerollsLeft = 0;
      applyRollFaces(state.currentRolls);
      els.toShopBtn.disabled = false;
      render();
      log('Roll locked in. Click Go To Store when ready.');
    }

    async function rerollDieAt(idx) {
      if (!state.pendingDieReroll || (state.dieRerollsLeft || 0) <= 0) return;
      if (!state.currentRolls || !state.currentRolls.length) {
        log('No dice to reroll.');
        state.pendingDieReroll = false;
        return;
      }
      const target = state.currentRolls[idx];
      if (!target) { log('No die in that slot.'); return; }
      const oldRolls = state.currentRolls;
      const newFace = rollDie(target.die);
      const newRolls = oldRolls.map((r, i) => (i === idx ? { die: r.die, face: newFace } : r));
      state.dieRerollsLeft -= 1;
      state.currentRolls = newRolls;
      log(`Rerolled die ${idx + 1}. (${state.dieRerollsLeft || 0} left)`);
      await animateSingleDie(idx, newRolls, oldRolls);
      renderDice(newRolls);
      render();
      if (state.dieRerollsLeft <= 0) {
        state.pendingDieReroll = false;
        state.dieRerollsLeft = 0;
        finalizeCurrentRoll();
      }
    }

    function cancelPendingDieReroll() {
      if (!state.pendingDieReroll) return;
      const carryOver = state.dieRerollsLeft || 0;
      if (carryOver > 0) {
        state.statuses.push({ type: 'dieRerollToken', amount: carryOver, expires: state.round + 1 });
        log(`Saved ${carryOver} die reroll${carryOver === 1 ? '' : 's'} for next round.`);
      }
      state.pendingDieReroll = false;
      state.dieRerollsLeft = 0;
      log('Die reroll cancelled. Finalizing roll.');
      finalizeCurrentRoll();
    }

    function replaceFaceOnDie(dieIdx, faceIdx) {
      const pending = state.pendingFacePurchase;
      if (!pending) return;
      const die = state.dice[dieIdx];
      if (!die) { log('No die in that slot.'); return; }
      const faces = cloneFaces(getDieFaces(die));
      if (!faces[faceIdx]) { log('No face in that slot.'); return; }
      faces[faceIdx] = cloneFace(pending.face);
      die.faces = faces;
      state.pendingFacePurchase = null;
      const dieDef = getDieDef(die.typeId);
      const dieName = dieDef ? dieDef.name : 'a die';
      log(`Replaced a face on ${dieName} with ${pending.face.label}.`);
      render();
    }

    function removeFaceFromDie(dieIdx, faceIdx) {
      if (!state.pendingFaceRemoval) return;
      const die = state.dice[dieIdx];
      if (!die) { log('No die in that slot.'); return; }
      const faces = [...getDieFaces(die)];
      if (!faces[faceIdx]) { log('No face in that slot.'); return; }
      if (faces.length <= 1) { log('Cannot remove the last face from a die.'); return; }
      if ((state.tokens.removeFace || 0) <= 0) { log('No face-removal tokens left.'); state.pendingFaceRemoval = false; render(); return; }
      faces.splice(faceIdx, 1);
      die.faces = faces;
      state.tokens.removeFace -= 1;
      if (state.tokens.removeFace <= 0) {
        state.pendingFaceRemoval = false;
      }
      log(`Removed a face. ${state.tokens.removeFace} face-removal token${state.tokens.removeFace === 1 ? '' : 's'} left.`);
      render();
    }

    function applyPendingFaceUpgrade(dieIdx, faceIdx) {
      const pending = state.pendingFaceUpgrade;
      if (!pending) return;
      const die = state.dice[dieIdx];
      if (!die) { log('No die in that slot.'); return; }
      const faces = cloneFaces(getDieFaces(die));
      const face = faces[faceIdx];
      if (!face) { log('No face in that slot.'); return; }
      if (pending.type === 'gold') {
        if (face.kind !== 'gold') { log('Select a gold face to upgrade.'); return; }
        const newGold = (face.gold || 0) + (pending.delta || 0);
        faces[faceIdx] = { ...face, gold: newGold, label: `Coins +${newGold}` };
        die.faces = faces;
        state.pendingFaceUpgrade = null;
        log(`Upgraded gold face to Coins +${newGold}.`);
        render();
        return;
      }
      if (pending.type === 'doubleIngredient') {
        if (face.kind !== 'ingredient') { log('Select an ingredient face to double.'); return; }
        const ing = face.ingredient || 'mana';
        faces[faceIdx] = faceForIngredient({ ingredient: ing, count: Math.max(2, face.count || 1) });
        die.faces = faces;
        state.pendingFaceUpgrade = null;
        log(`Upgraded ${ing} face to double (${faces[faceIdx].label}).`);
        render();
      }
    }

    function replaceDieAtIndex(idx) {
      if (!state.pendingDiePurchase) return;
      const pending = state.pendingDiePurchase;
      if (state.gold < pending.cost) { log('Not enough gold anymore.'); state.pendingDiePurchase = null; render(); return; }
      const removed = state.dice.splice(idx, 1)[0];
      state.dice.splice(idx, 0, makeDie(pending.typeId));
      state.gold -= pending.cost;
      recordItemBought();
      const removedType = getDieDef(removed.typeId);
      log(`Replaced ${removedType ? removedType.name : 'a die'} with ${pending.name}.`);
      if (state.diceShopOffers && pending.offerIndex !== undefined) {
        state.diceShopOffers[pending.offerIndex] = null;
      }
      state.pendingDiePurchase = null;
      render();
    }

    function sacrificeDieAtIndex(idx) {
      const pending = state.pendingDieSacrifice;
      if (!pending) return;
      if (!state.dice[idx]) { log('No die in that slot.'); return; }
      const removed = state.dice.splice(idx, 1)[0];
      const def = getDieDef(removed.typeId);
      state.maxDice = Math.max(1, state.maxDice - 1);
      state.statuses.push({ type: 'doubleCoinIng', expires: pending.expires || effectTargetRound() });
      state.pendingDieSacrifice = null;
      log(`Sacrificed ${def ? def.name : 'a die'}. Next roll: coins and ingredients doubled. Max dice now ${state.maxDice}.`);
      render();
    }

    function empowerDieAtIndex(idx) {
      const pending = state.pendingDieEmpower;
      if (!pending) return;
      const die = state.dice[idx];
      if (!die) { log('No die in that slot.'); return; }
      state.statuses.push({
        type: 'dieMod',
        dieId: die.id,
        goldMult: pending.goldMult || 1,
        ingMult: pending.ingMult || 1,
        name: 'Plaguefire Bulwark'
      });
      state.pendingDieEmpower = null;
      const def = getDieDef(die.typeId);
      log(`Empowered ${def ? def.name : 'a die'}: coins x${pending.goldMult || 1}, ingredients x${pending.ingMult || 1} (permanent).`);
      render();
    }

    function recordPotionBrew(potion) {
      state.stats.potionsBrewed += 1;
      state.stats.potionValue += potion.sell;
    }

    function recordPotionConsume() {
      state.stats.potionsConsumed += 1;
    }

    function recordItemBought() {
      state.stats.itemsBought += 1;
    }

    function applyPurgeUpgradeForRound() {
      const perk = state.statuses.find((s) => s.type === 'purgeUpgrade');
      if (!perk) return;

      const purgeTargets = state.dice.filter((d) => getDieFaces(d).length > 1);
      if (purgeTargets.length) {
        const target = pick(purgeTargets);
        const faces = cloneFaces(getDieFaces(target));
        const idx = Math.floor(Math.random() * faces.length);
        faces.splice(idx, 1);
        target.faces = faces;
        log('Character perk: purged 1 face from a die.');
      } else {
        log('Character perk: no die had a removable face.');
      }

      const upgradeCandidates = [];
      state.dice.forEach((die) => {
        const faces = cloneFaces(getDieFaces(die));
        faces.forEach((face, faceIdx) => {
          if (face.kind === 'gold' || face.kind === 'ingredient') {
            upgradeCandidates.push({ die, faces, face, faceIdx });
          }
        });
      });
      if (upgradeCandidates.length) {
        const choice = pick(upgradeCandidates);
        const { die, faces, faceIdx, face } = choice;
        if (face.kind === 'gold') {
          const newGold = (face.gold || 0) + (perk.goldDelta || 2);
          faces[faceIdx] = { ...face, gold: newGold, label: `Coins +${newGold}` };
        } else {
          const newCount = Math.max(1, (face.count || 1) + (perk.ingDelta || 1));
          faces[faceIdx] = { ...face, count: newCount, label: `${ingredientLabels[face.ingredient] || face.ingredient}${newCount > 1 ? ` x${newCount}` : ''}` };
        }
        die.faces = faces;
        log('Character perk: upgraded a face (coins +2 or ingredient +1).');
      } else {
        log('Character perk: no valid face to upgrade.');
      }
    }

    function mergeIntoLifetime() {
      lifetimeStats.gamesPlayed += 1;
      lifetimeStats.potionsBrewed += state.stats.potionsBrewed;
      lifetimeStats.potionsConsumed += state.stats.potionsConsumed;
      lifetimeStats.potionValue += state.stats.potionValue;
      lifetimeStats.itemsBought += state.stats.itemsBought;
      lifetimeStats.highScore = Math.max(lifetimeStats.highScore, state.stats.score || 0);
      ingredients.forEach((ing) => {
        lifetimeStats.ingredients[ing] += state.stats.ingredients[ing] || 0;
      });
      saveLifetimeStatsToStorage();
    }

    function render() {
      renderHeader();
      renderIngredients();
      renderCauldron();
      renderPotions();
      if (state.currentRolls && state.currentRolls.length) {
        renderDice(state.currentRolls);
      }
      renderShop();
      renderInventory();
      renderInventoryPotions();
      renderInventoryItems();
      renderDiceShop();
      renderFaceShop();
      renderStatuses();
    }

    function startRound() {
      if (state.pendingDieSacrifice && state.pendingDieSacrifice.expires && state.pendingDieSacrifice.expires < state.round) {
        state.pendingDieSacrifice = null;
      }
      state.stage = 'roll';
      const shopRerollBonus = state.statuses
        .filter((s) => s.type === 'shopRerollMaxBonus')
        .reduce((sum, s) => sum + (s.amount || 0), 0);
      const maxShopRerolls = 3 + shopRerollBonus;
      state.shopRerollsLeft = maxShopRerolls;
      const passiveRerolls = state.statuses
        .filter((s) => s.type === 'passiveDieReroll')
        .reduce((sum, s) => sum + (s.amount || 0), 0);
      if (passiveRerolls > 0) {
        state.statuses.push({ type: 'dieRerollToken', amount: passiveRerolls, expires: state.round });
        log(`Passive: stored ${passiveRerolls} die reroll${passiveRerolls === 1 ? '' : 's'} for this round.`);
      }
      applyPurgeUpgradeForRound();
      const bankedGold = state.statuses.filter((s) => s.type === 'bankedGoldNext' && s.expires === state.round);
      if (bankedGold.length) {
        const total = bankedGold.reduce((sum, s) => sum + (s.amount || 0), 0);
        if (total > 0) {
          gainGold(total);
          log(`Banked payout: +${total} Gold from last round.`);
        }
        state.statuses = state.statuses.filter((s) => !(s.type === 'bankedGoldNext' && s.expires === state.round));
      }
      const unusedGoldStatuses = state.statuses.filter((s) => s.type === 'unusedIngGold' && s.expires === state.round);
      if (unusedGoldStatuses.length) {
        unusedGoldStatuses.forEach((s) => {
          const allowed = new Set(Array.isArray(s.ings) && s.ings.length ? s.ings : ingredients);
          const count = state.ingredients.filter((ing) => allowed.has(ing)).length;
          const gain = count * (s.amount || 0);
          if (gain > 0) {
            gainGold(gain);
            log(`Hellfire Panacea: +${gain} Gold from ${count} unused ingredient${count === 1 ? '' : 's'}.`);
          } else {
            log('Hellfire Panacea: no unused ingredients to convert.');
          }
        });
        state.statuses = state.statuses.filter((s) => !(s.type === 'unusedIngGold' && s.expires === state.round));
      }
      state.ingredients = [];
      state.cauldron = [];
      state.rolled = false;
      state.rollResolved = false;
      state.currentRolls = [];
      state.rollSnapshot = null;
      state.effectNotes = [];
      state.pendingDieReroll = false;
      state.pendingDiePurchase = null;
      refreshShopOffers();
      grantPassiveRoundGold();
      setView('roll');
      log(`Round ${state.round} start.`);
      renderDice([]);
      render();
      els.toShopBtn.disabled = true;
    }

    function finishRound() {
      state.round += 1;
      state.statuses = state.statuses.filter((s) => s.expires === undefined || s.expires >= state.round);
      if (state.round > state.maxRounds) {
        els.rollBtn.disabled = true;
        log('Game over. Thanks for playing!');
        endGame();
      } else {
        startRound();
      }
    }

    function openGameOverModal(finalRunStats) {
      renderStatsBlock(finalRunStats, els.gameOverStats, '');
      els.gameOverModal.classList.remove('hidden');
    }

    function closeGameOverModal() {
      if (els.gameOverModal) els.gameOverModal.classList.add('hidden');
      state = freshState();
      renderDice([]);
      render();
      setView('start');
    }

    function endGame() {
      mergeIntoLifetime();
      openGameOverModal(state.stats);
    }

    function grantPassiveRoundGold() {
      const gain = state.statuses
        .filter((s) => s.type === 'passiveRoundGold')
        .reduce((sum, s) => sum + (s.amount || 0), 0);
      if (gain > 0) {
        gainGold(gain);
        log(`Passive income: +${gain} Gold for this round.`);
      }
    }

    function computeBonusDice() {
      const generic = state.statuses
        .filter((s) => s.type === 'bonusDice' && s.expires === state.round)
        .reduce((sum, s) => sum + s.amount, 0);
      const clones = state.statuses
        .filter((s) => s.type === 'bonusCloneDie' && s.expires === state.round)
        .map((s) => s.die)
        .filter(Boolean);
      return { generic, clones };
    }

    function duplicateDiceForRound() {
      const status = state.statuses.find((s) => s.type === 'duplicateDice' && s.expires === state.round);
      if (!status || !status.clones) return [];
      return status.clones;
    }

    function goldFaceBonusForRoll() {
      const temp = state.statuses
        .filter((s) => s.type === 'goldFaceBonus' && s.expires === state.round)
        .reduce((sum, s) => sum + s.amount, 0);
      const passive = state.statuses
        .filter((s) => s.type === 'passiveGoldOnGold')
        .reduce((sum, s) => sum + (s.amount || 0), 0);
      return temp + passive;
    }

    function passiveGoldFloorValue() {
      return state.statuses
        .filter((s) => s.type === 'passiveGoldFloor')
        .reduce((max, s) => Math.max(max, s.floor || 0), 0);
    }

    function takeDelayedIngredientsForRound() {
      const out = [];
      state.statuses = state.statuses.filter((s) => {
        if (s.type === 'delayedIngredients' && s.expires === state.round) {
          if (Array.isArray(s.ings)) out.push(...s.ings);
          return false; // consume once
        }
        return true;
      });
      return out;
    }

    function convertIngredientsForRound(ings) {
      if (!ings || !ings.length) return ings;
      const converters = state.statuses.filter((s) => s.type === 'convertIngredient' && s.expires === state.round);
      if (!converters.length) return ings;
      const out = [];
      const counts = {};
      ings.forEach((ing) => {
        let replaced = false;
        converters.forEach((c) => {
          if (c.from === ing) {
            const mult = c.multiplier && c.multiplier > 0 ? c.multiplier : 1;
            for (let i = 0; i < mult; i += 1) out.push(c.to || ing);
            counts[ing] = (counts[ing] || 0) + 1;
            replaced = true;
          }
        });
        if (!replaced) out.push(ing);
      });
      const parts = Object.entries(counts).map(([k, v]) => `${v} ${k}`);
      if (parts.length) {
        log(`Converted ${parts.join(', ')} this roll.`);
      }
      return out;
    }

    function convertIngredientsToGold(summary, goldMult = 1) {
      if (!summary.ingredients.length) return;
      const conv = state.statuses.find((s) => s.type === 'ingToGold' && s.expires === state.round);
      if (!conv) return;
      const per = conv.amount !== undefined ? conv.amount : 6;
      const count = summary.ingredients.length;
      const gain = per * count;
      const finalGain = gain * Math.max(1, goldMult);
      summary.ingredients = [];
      if (finalGain > 0) {
        gainGold(finalGain);
        const notes = summary.notes || summary.effectNotes || state.effectNotes || [];
        notes.push(`IngredientsGold: +${finalGain} Gold (${count} ingredients @${per}${goldMult > 1 ? ` x${goldMult}` : ''})`);
        log(`Converted ${count} ingredient${count === 1 ? '' : 's'} into ${finalGain} Gold${goldMult > 1 ? ' (doubled)' : ''}.`);
      }
    }

    async function animateRollDisplay(finalRolls) {
      const baseDelays = [20, 30, 45, 70, 105, 150, 225, 310, 460];
      const delays = baseDelays.map((d) => Math.round(d * (0.9 + Math.random() * 0.2))); // 10%
      let current = finalRolls.map(({ die }) => ({ die, face: randomFaceForDie(die) }));
      renderDice(current);
      for (const d of delays) {
        await new Promise((r) => setTimeout(r, d));
        current = current.map((entry) => {
          if (Math.random() < 0.7) {
            return { die: entry.die, face: randomFaceForDie(entry.die) };
          }
          return entry;
        });
        renderDice(current);
      }
    }

    async function animateSingleDie(targetIdx, finalRolls, baseRolls) {
      const baseDelays = [45, 60, 80, 120, 160];
      let current = [...baseRolls];
      renderDice(current);
      for (const d of baseDelays) {
        await new Promise((r) => setTimeout(r, d));
        current = current.map((entry, i) => (i === targetIdx
          ? { die: entry.die, face: randomFaceForDie(entry.die) }
          : entry));
        renderDice(current);
      }
      const final = current.map((entry, i) => (i === targetIdx ? finalRolls[i] : entry));
      renderDice(final);
    }

    async function handleRoll() {
      if (state.rolled) return;
      if (state.pendingDieSacrifice) { log('Select a die to sacrifice before rolling.'); return; }
      if (state.pendingDieEmpower) { log('Select a die to empower before rolling.'); return; }
      const snapshot = {
        gold: state.gold,
        ingredients: [...state.ingredients],
        statsIngredients: { ...state.stats.ingredients },
        score: state.stats.score
      };
      state.effectNotes = [];
      const { generic: bonusDice, clones: bonusClones } = computeBonusDice();
      const dupDice = duplicateDiceForRound();
      const baseDice = state.dice.slice(0, state.maxDice);
      const diceToRoll = [...baseDice];
      dupDice.forEach((clone) => {
        if (diceToRoll.length < state.maxDice) {
          diceToRoll.push(clone);
        } else {
          log('Duplicate die could not be added (at max dice).');
        }
      });
      bonusClones.forEach((clone) => {
        if (diceToRoll.length < state.maxDice) {
          diceToRoll.push(clone);
        } else {
          log('Bonus die copy could not be added (at max dice).');
        }
      });
      const extraSlots = state.maxDice - diceToRoll.length;
      const extra = Math.min(bonusDice, extraSlots);
      for (let i = 0; i < extra; i += 1) {
        diceToRoll.push({ id: `bonus-${i}`, typeId: 'apprentice' });
      }

      const totalDice = diceToRoll.length;
      const rolls = [];
      for (let i = 0; i < totalDice; i += 1) {
        const die = diceToRoll[i];
        const face = rollDie(die);
        rolls.push({ die, face });
      }

      await animateRollDisplay(rolls);
      state.currentRolls = rolls;
      state.rollSnapshot = snapshot;
      state.pendingDieReroll = false;
      state.rolled = true;
      state.rollResolved = false;
      const dieReroll = state.statuses.find((s) => s.type === 'dieRerollToken' && s.expires === state.round);
      if (dieReroll) {
        state.pendingDieReroll = true;
        state.dieRerollsLeft = (state.dieRerollsLeft || 0) + (dieReroll.amount || 1);
        state.statuses = state.statuses.filter((s) => s !== dieReroll);
        log(`Die reroll ready: click a die to reroll (left: ${state.dieRerollsLeft}).`);
      } else {
        finalizeCurrentRoll();
      }
      renderDice(rolls);
      render();
      els.rollBtn.disabled = true;
      els.toShopBtn.disabled = !state.rollResolved;
      if (state.pendingDieReroll) log('Use rerolls now or cancel to finalize the roll.');
    }

    function applyCharacterToState() {
      if (!characterClasses.length) return;
      const choice = characterClasses.find((c) => c.id === selectedCharacterId) || characterClasses[0];
      if (!choice) return;
      state.character = choice.id;
      state.statuses.push({ type: 'character', name: choice.name, fromCharacter: true });
      const before = new Set(state.statuses);
      choice.apply(state);
      state.statuses.forEach((s) => {
        if (!before.has(s)) s.fromCharacter = true;
      });
      log(`Starting as ${choice.name}.`);
    }

    function startGame() {
      hideAllModals();
      state = freshState();
      els.log.innerHTML = '';
      ensureToggleDefaults();
      applyCharacterToState();
      refreshShopOffers();
      renderDice([]);
      render();
      startRound();
    }

    function toggleHowTo() {
      if (!els.howToPlay || !els.startHowToBtn) return;
      const isHidden = els.howToPlay.classList.contains('hidden');
      els.howToPlay.classList.toggle('hidden');
      els.startHowToBtn.textContent = isHidden ? 'Hide How to Play' : 'How to Play';
    }

    function renderToggleList(container, entries, enabledMap) {
      if (!container) return;
      container.innerHTML = '';
      entries.forEach(({ id, label }) => {
        const row = document.createElement('label');
        row.className = 'list-item';
        row.style.display = 'flex';
        row.style.justifyContent = 'space-between';
        row.style.alignItems = 'center';
        row.innerHTML = `<div><strong>${label}</strong></div>`;
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = enabledMap[id] !== false;
        cb.dataset.toggleId = id;
        row.appendChild(cb);
        container.appendChild(row);
      });
    }

    function collectToggleValues(container, fallbackIds) {
      const map = {};
      if (!container) {
        fallbackIds.forEach((id) => { map[id] = true; });
        return map;
      }
      container.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
        map[cb.dataset.toggleId] = cb.checked;
      });
      return map;
    }

    function populateSettingsForm() {
      ensureToggleDefaults();
      els.settingStartingDice.value = settings.startingDice;
      els.settingStartingGold.value = settings.startingGold;
      els.settingMaxRounds.value = settings.maxRounds;
      els.settingShopSlots.value = settings.shopItemSlots;
      renderToggleList(els.settingItemToggles, itemIds.map((id) => ({ id, label: id })), settings.enabledItems);
      renderToggleList(els.settingDieToggles, dieTypeIds.map((id) => ({ id, label: id })), settings.enabledDiceTypes);
      const faceEntries = faceKeys.map((k) => {
        if (k.startsWith('eff_doubleIng_')) {
          const ing = k.replace('eff_doubleIng_', '');
          return { id: k, label: `Double ${ing}` };
        }
        if (k.startsWith('ing2_')) {
          const ing = k.replace('ing2_', '');
          return { id: k, label: `${ing} x2 face` };
        }
        if (k === 'eff_doubleGoldAll') return { id: k, label: 'Double all Gold' };
        if (k === 'eff_boostGold') return { id: k, label: 'Boost: +1 Gold per ingredient' };
        if (k === 'eff_goldAura') return { id: k, label: 'Mint Aura: +1 to all rolled gold faces' };
        if (k === 'eff_purgeFace') return { id: k, label: 'Purge a rolled face' };
        return { id: k, label: k.replace('ing_', '').replace('eff_', '') };
      });
      renderToggleList(els.settingFaceToggles, faceEntries, settings.enabledFaces);
    }

    function openSettings() {
      populateSettingsForm();
      els.settingsModal.classList.remove('hidden');
    }

    function closeSettingsModal() {
      els.settingsModal.classList.add('hidden');
    }

    function hideAllModals() {
      if (els.settingsModal) els.settingsModal.classList.add('hidden');
      if (els.recipeModal) els.recipeModal.classList.add('hidden');
      if (els.invalidBrewModal) els.invalidBrewModal.classList.add('hidden');
      if (els.statsModal) els.statsModal.classList.add('hidden');
      if (els.gameOverModal) {
        if (!els.gameOverModal.classList.contains('hidden')) {
          closeGameOverModal();
          return;
        }
        els.gameOverModal.classList.add('hidden');
      }
    }

    function readNumber(el, fallback, min, max) {
      const n = parseInt(el.value, 10);
      if (Number.isNaN(n)) return fallback;
      return clamp(n, min, max);
    }

    function saveSettings() {
      settings = {
        startingDice: readNumber(els.settingStartingDice, defaultSettings.startingDice, 1, 9),
        startingGold: Math.max(0, readNumber(els.settingStartingGold, defaultSettings.startingGold, 0, 999)),
        maxRounds: readNumber(els.settingMaxRounds, defaultSettings.maxRounds, 1, 99),
        shopItemSlots: readNumber(els.settingShopSlots, defaultSettings.shopItemSlots, 1, 6),
        enabledItems: collectToggleValues(els.settingItemToggles, itemIds),
        enabledDiceTypes: collectToggleValues(els.settingDieToggles, dieTypeIds),
        enabledFaces: collectToggleValues(els.settingFaceToggles, faceKeys)
      };
      saveSettingsToStorage();
      closeSettingsModal();
      log('Settings saved. New games will use these values.');
      refreshShopOffers();
      renderShop();
    }

    function resetSettings() {
      settings = { ...defaultSettings };
      ensureToggleDefaults();
      populateSettingsForm();
      saveSettingsToStorage();
      log('Settings reset to defaults.');
      refreshShopOffers();
      renderShop();
    }

    function sellAllPotions() {
      if (!state.potions.length) return;
      const bonus = potionSellBonusForRound();
      let sum = 0;
      state.potions.forEach((p) => { sum += p.sell + bonus; });
      gainGold(sum);
      log(`Sold all potions for ${sum} Gold${bonus ? ` (includes +${bonus} per potion)` : ''}.`);
      state.potions = [];
      render();
    }

    // Events
    els.rollBtn.addEventListener('click', handleRoll);
    if (els.sellAllShop) els.sellAllShop.addEventListener('click', sellAllPotions);
    els.openRecipeBook.addEventListener('click', openRecipe);
    els.closeRecipeBook.addEventListener('click', closeRecipe);
    els.closeInvalidBrew.addEventListener('click', hideInvalidBrew);
    els.invalidBrewModal.addEventListener('click', (e) => {
      if (e.target === els.invalidBrewModal) hideInvalidBrew();
    });
    els.startGameBtn.addEventListener('click', () => {
      pickCharacterDraft();
      state.prevViewBeforeCharacter = 'start';
      setView('character');
      renderCharacterSelect();
      log('Choose your brewer, then start.');
    });
    if (els.chooseCharacterBtn) {
      els.chooseCharacterBtn.addEventListener('click', () => {
        if (state.pendingCharacterReselect) {
          // Clear previous character-derived statuses
          state.statuses = state.statuses.filter((s) => !s.fromCharacter);
          applyCharacterToState();
          state.pendingCharacterReselect = false;
          setView(state.prevViewBeforeCharacter || 'shop');
          render();
          log('Character reselected.');
        } else {
          startGame();
        }
      });
    }
    els.startRecipeBtn.addEventListener('click', openRecipe);
    els.startStatsBtn.addEventListener('click', () => openStatsModal());
    els.startSettingsBtn.addEventListener('click', openSettings);
    if (els.startHowToBtn) els.startHowToBtn.addEventListener('click', toggleHowTo);
    els.toShopBtn.addEventListener('click', () => { setView('shop'); render(); });
    els.backToBrew.addEventListener('click', finishRound);
    els.brewBtn.addEventListener('click', brewCauldron);
    els.autoBrewBtn.addEventListener('click', autoBrew);
    els.clearCauldron.addEventListener('click', clearCauldronContents);
    if (els.buyExtraSlotBtn) els.buyExtraSlotBtn.addEventListener('click', buyExtraSlot);
    els.rerollShop.addEventListener('click', () => {
      if (typeof state.shopRerollsLeft !== 'number') state.shopRerollsLeft = 3;
      if (state.shopRerollsLeft <= 0) {
        log('No shop rerolls left this run (max 3).');
        return;
      }
      if (state.tokens.reroll > 0) {
        state.tokens.reroll -= 1;
        state.shopRerollsLeft -= 1;
        refreshShopOffers();
        log(`Rerolled entire shop using a token. (${state.shopRerollsLeft} left)`);
        render();
        return;
      }
      const cost = shopRerollCost();
      if (state.gold < cost) { log(`Need ${cost} Gold or a token to reroll shop.`); return; }
      state.gold -= cost;
      state.shopRerollsLeft -= 1;
      refreshShopOffers();
      log(`Rerolled entire shop for ${cost} Gold. (${state.shopRerollsLeft} left)`);
      render();
    });
    els.closeSettings.addEventListener('click', closeSettingsModal);
    els.saveSettings.addEventListener('click', saveSettings);
    els.resetSettings.addEventListener('click', resetSettings);
    els.settingsModal.addEventListener('click', (e) => {
      if (e.target === els.settingsModal) closeSettingsModal();
    });
    els.closeStats.addEventListener('click', closeStatsModal);
    els.closeGameOver.addEventListener('click', closeGameOverModal);
    els.statsModal.addEventListener('click', (e) => { if (e.target === els.statsModal) closeStatsModal(); });
    els.gameOverModal.addEventListener('click', (e) => { if (e.target === els.gameOverModal) closeGameOverModal(); });
    els.recipeModal.addEventListener('click', (e) => {
      if (e.target === els.recipeModal) closeRecipe();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideAllModals();
      }
    });

    // Init
    hideAllModals();
    pickCharacterDraft();
    renderCharacterSelect();
    refreshShopOffers();
    renderDice([]);
    render();
    setView('start');
  </script>
</body>
  </html>
